[
  {
    "library": "Kotlin",
    "entries": [
      {
        "library_name": "Kotlin",
        "url": "https://kotlinlang.org/docs/whatsnew20.html",
        "version": "Unknown version",
        "title": "What's new in Kotlin 2.0.0 | Kotlin Documentation",
        "release_date": "Unknown release date",
        "content": "What's new in Kotlin 2.0.0 Edit page01 October 2025 Released: May 21, 2024 The Kotlin 2.0.0 release is out and the new Kotlin K2 compiler is Stable! Additionally, here are some other highlights: * New Compose compiler Gradle plugin * Generation of lambda functions using invokedynamic * The kotlinx-metadata-jvm library is now Stable * Monitoring GC performance in Kotlin/Native with signposts on Apple platforms * Resolving conflicts in Kotlin/Native with Objective-C methods * Support for named export in Kotlin/Wasm * Support for unsigned primitive types in functions with @JsExport in Kotlin/Wasm * Optimize production builds by default using Binaryen * New Gradle DSL for compiler options in multiplatform projects * Stable replacement of the enum class values generic function * Stable AutoCloseable interface Kotlin 2.0 is a huge milestone for the JetBrains team. This release was the center of KotlinConf 2024. Check out the opening keynote, where we announced exciting updates and addressed the recent work on the Kotlin language: IDE support The Kotlin plugins that support Kotlin 2.0.0 are bundled in the latest IntelliJ IDEA and Android Studio. You don't need to update the Kotlin plugin in your IDE. All you need to do is to change the Kotlin version to Kotlin 2.0.0 in your build scripts. * For details about IntelliJ IDEA's support for the Kotlin K2 compiler, see Support in IDEs. * For more details about IntelliJ IDEA's support for Kotlin, see Kotlin releases. Kotlin K2 compiler The road to the K2 compiler has been a long one, but now the JetBrains team is finally ready to announce its stabilization. In Kotlin 2.0.0, the new Kotlin K2 compiler is used by default and it is Stable for all target platforms: JVM, Native, Wasm, and JS. The new compiler brings major performance improvements, speeds up new language feature development, unifies all platforms that Kotlin supports, and provides a better architecture for multiplatform projects. The JetBrains team has ensured the quality of the new compiler by successfully compiling 10 million lines of code from selected user and internal projects. 18,000 developers were involved in the stabilization process, testing the new K2 compiler across a total of 80,000 projects and reporting any problems they found. To help make the migration process to the new compiler as smooth as possible, we've created a K2 compiler migration guide. This guide explains the many benefits of the compiler, highlights any changes you might encounter, and describes how to roll back to the previous version if necessary. In a blog post, we explored the performance of the K2 compiler in different projects. Check it out if you'd like to see real data on how the K2 compiler performs and find instructions on how to collect performance benchmarks from your own projects. You can also watch this talk from KotlinConf 2024, where Michail Zarečenskij, the lead language designer, discusses the feature evolution in Kotlin and the K2 compiler: Current K2 compiler limitations Enabling K2 in your Gradle project comes with certain limitations that can affect projects using Gradle versions below 8.3 in the following cases: * Compilation of source code from buildSrc. * Compilation of Gradle plugins in included builds. * Compilation of other Gradle plugins if they are used in projects with Gradle versions below 8.3. * Building Gradle plugin dependencies. If you encounter any of the problems mentioned above, you can take the following steps to address them: * Set the language version for buildSrc, any Gradle plugins, and their dependencies: kotlin { * compilerOptions { * languageVersion.set(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_1_9) * apiVersion.set(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_1_9) * } * } If you configure language and API versions for specific tasks, these values will override the values set by the compilerOptions extension. In this case, language and API versions should not be higher than 1.9. * Update the Gradle version in your project to 8.3 or later. Smart cast improvements The Kotlin compiler can automatically cast an object to a type in specific cases, saving you the trouble of having to explicitly cast it yourself. This is called smart casting. The Kotlin K2 compiler now performs smart casts in even more scenarios than before. In Kotlin 2.0.0, we've made improvements related to smart casts in the following areas: * Local variables and further scopes * Type checks with logical or operator * Inline functions * Properties with function types * Exception handling * Increment and decrement operators Local variables and further scopes Previously, if a variable was evaluated as not null within an if condition, the variable would be smart-cast. Information about this variable would then be shared further within the scope of the if block. However, if you declared the variable outside the if condition, no information about the variable would be available within the if condition, so it couldn't be smart-cast. This behavior was also seen with when expressions and while loops. From Kotlin 2.0.0, if you declare a variable before using it in your if, when, or while condition, then any information collected by the compiler about the variable will be accessible in the corresponding block for smart-casting. This can be useful when you want to do things like extract boolean conditions into variables. Then, you can give the variable a meaningful name, which will improve your code readability and make it possible to reuse the variable later in your code. For example: class Cat { fun purr() { println(\"Purr purr\") } } ​ fun petAnimal(animal: Any) { val isCat = animal is Cat if (isCat) { // In Kotlin 2.0.0, the compiler can access // information about isCat, so it knows that // animal was smart-cast to the type Cat. // Therefore, the purr() function can be called. // In Kotlin 1.9.20, the compiler doesn't know // about the smart cast, so calling the purr() // function triggers an error. animal.purr() } } ​ fun main() { val kitty = Cat() petAnimal(kitty) // Purr purr } Open in Playground → Target: JVM Running on v.2.3.0 Type checks with logical or operator In Kotlin 2.0.0, if you combine type checks for objects with an or operator (||), a smart cast is made to their closest common supertype. Before this change, a smart cast was always made to the Any type. In this case, you still had to manually check the object type afterward before you could access any of its properties or call its functions. For example: interface Status { fun signal() {} } interface Ok : Status interface Postponed : Status interface Declined : Status fun signalCheck(signalStatus: Any) { if (signalStatus is Postponed || signalStatus is Declined) { // signalStatus is smart-cast to a common supertype Status signalStatus.signal() // Prior to Kotlin 2.0.0, signalStatus is smart cast // to type Any, so calling the signal() function triggered an // Unresolved reference error. The signal() function can only // be called successfully after another type check: // check(signalStatus is Status) // signalStatus.signal() } } The common supertype is an approximation of a union type. Union types are not supported in Kotlin. Inline functions In Kotlin 2.0.0, the K2 compiler treats inline functions differently, allowing it to determine in combination with other compiler analyses whether it's safe to smart-cast. Specifically, inline functions are now treated as having an implicit callsInPlace contract. This means that any lambda functions passed to an inline function are called in place. Since lambda functions are called in place, the compiler knows that a lambda function can't leak references to any variables contained within its function body. The compiler uses this knowledge along with other compiler analyses to decide whether it's safe to smart-cast any of the captured variables. For example: interface Processor { fun process() } inline fun inlineAction(f: () -> Unit) = f() fun nextProcessor(): Processor? = null fun runProcessor(): Processor? { var processor: Processor? = null inlineAction { // In Kotlin 2.0.0, the compiler knows that processor // is a local variable, and inlineAction() is an inline function, so // references to processor can't be leaked. Therefore, it's safe // to smart-cast processor. // If processor isn't null, processor is smart-cast if (processor != null) { // The compiler knows that processor isn't null, so no safe call // is needed processor.process() // In Kotlin 1.9.20, you have to perform a safe call: // processor?.process() } processor = nextProcessor() } return processor } Properties with function types In previous versions of Kotlin, there was a bug that meant that class properties with a function type weren't smart-cast. We fixed this behavior in Kotlin 2.0.0 and the K2 compiler. For example: class Holder(val provider: (() -> Unit)?) { fun process() { // In Kotlin 2.0.0, if provider isn't null, then // provider is smart-cast if (provider != null) { // The compiler knows that provider isn't null provider() // In 1.9.20, the compiler doesn't know that provider isn't // null, so it triggers an error: // Reference has a nullable type '(() -> Unit)?', use explicit '?.invoke()' to make a function-like call instead } } } This change also applies if you overload your invoke operator. For example: interface Provider { operator fun invoke() } interface Processor : () -> String class Holder(val provider: Provider?, val processor: Processor?) { fun process() { if (provider != null) { provider() // In 1.9.20, the compiler triggers an error: // Reference has a nullable type 'Provider?' use explicit '?.invoke()' to make a function-like call instead } } } Exception handling In Kotlin 2.0.0, we've made improvements to exception handling so that smart cast information can be passed on to catch and finally blocks. This change makes your code safer as the compiler keeps track of whether your object has a nullable type. For example: fun testString() { var stringInput: String? = null // stringInput is smart-cast to String type stringInput = \"\" try { // The compiler knows that stringInput isn't null println(stringInput.length) // 0 ​ // The compiler rejects previous smart cast information for // stringInput. Now stringInput has the String? type. stringInput = null ​ // Trigger an exception if (2 > 1) throw Exception() stringInput = \"\" } catch (exception: Exception) { // In Kotlin 2.0.0, the compiler knows stringInput // can be null, so stringInput stays nullable. println(stringInput?.length) // null ​ // In Kotlin 1.9.20, the compiler says that a safe call isn't // needed, but this is incorrect. } } ​ Open in Playground → Target: JVM Running on v.2.3.0 Increment and decrement operators Prior to Kotlin 2.0.0, the compiler didn't understand that the type of an object can change after using an increment or decrement operator. As the compiler couldn't accurately track the object type, your code could lead to unresolved reference errors. In Kotlin 2.0.0, this has been fixed: interface Rho { operator fun inc(): Sigma = TODO() } ​ interface Sigma : Rho { fun sigma() = Unit } ​ interface Tau { fun tau() = Unit } ​ fun main(input: Rho) { var unknownObject: Rho = input ​ // Check if unknownObject inherits from the Tau interface // Note, it's possible that unknownObject inherits from both // Rho and Tau interfaces. if (unknownObject is Tau) { ​ // Use the overloaded inc() operator from interface Rho. // In Kotlin 2.0.0, the type of unknownObject is smart-cast to // Sigma. ++unknownObject ​ // In Kotlin 2.0.0, the compiler knows unknownObject has type // Sigma, so the sigma() function can be called successfully. unknownObject.sigma() ​ // In Kotlin 1.9.20, the compiler doesn't perform a smart cast // when inc() is called so the compiler still thinks that // unknownObject has type Tau. Calling the sigma() function // throws a compile-time error. // In Kotlin 2.0.0, the compiler knows unknownObject has type // Sigma, so calling the tau() function throws a compile-time // error. unknownObject.tau() // Unresolved reference 'tau' ​ // In Kotlin 1.9.20, since the compiler mistakenly thinks that // unknownObject has type Tau, the tau() function can be called, // but it throws a ClassCastException. } } Open in Playground → Target: JVM Running on v.2.3.0 Kotlin Multiplatform improvements In Kotlin 2.0.0, we've made improvements in the K2 compiler related to Kotlin Multiplatform in the following areas: * Separation of common and platform sources during compilation * Different visibility levels of expected and actual declarations Separation of common and platform sources during compilation Previously, the design of the Kotlin compiler prevented it from keeping common and platform source sets separate at compile time. As a consequence, common code could access platform code, which resulted in different behavior between platforms. In addition, some compiler settings and dependencies from common code used to leak into platform code. In Kotlin 2.0.0, our implementation of the new Kotlin K2 compiler included a redesign of the compilation scheme to ensure strict separation between common and platform source sets. This change is most noticeable when you use expected and actual functions. Previously, it was possible for a function call in your common code to resolve to a function in platform code. For example: Common code Platform code fun foo(x: Any) = println(\"common foo\") fun exampleFunction() { foo(42) } // JVM fun foo(x: Int) = println(\"platform foo\") // JavaScript // There is no foo() function overload // on the JavaScript platform In this example, the common code has different behavior depending on which platform it is run on: * On the JVM platform, calling the foo() function in the common code results in the foo() function from the platform code being called as platform foo. * On the JavaScript platform, calling the foo() function in the common code results in the foo() function from the common code being called as common foo, as there is no such function available in the platform code. In Kotlin 2.0.0, common code doesn't have access to platform code, so both platforms successfully resolve the foo() function to the foo() function in the common code: common foo. In addition to the improved consistency of behavior across platforms, we also worked hard to fix cases where there was conflicting behavior between IntelliJ IDEA or Android Studio and the compiler. For instance, when you used expected and actual classes, the following would happen: Common code Platform code expect class Identity { fun confirmIdentity(): String } fun common() { // Before 2.0.0, // it triggers an IDE-only error Identity().confirmIdentity() // RESOLUTION_TO_CLASSIFIER : Expected class // Identity has no default constructor. } actual class Identity { actual fun confirmIdentity() = \"expect class fun: jvm\" } In this example, the expected class Identity has no default constructor, so it can't be called successfully in common code. Previously, an error was only reported by the IDE, but the code still compiled successfully on the JVM. However, now the compiler correctly reports an error: Expected class 'expect class Identity : Any' does not have default constructor When resolution behavior doesn't change We're still in the process of migrating to the new compilation scheme, so the resolution behavior is still the same when you call functions that aren't within the same source set. You'll notice this difference mainly when you use overloads from a multiplatform library in your common code. Suppose you have a library, which has two whichFun() functions with different signatures: // Example library // MODULE: common fun whichFun(x: Any) = println(\"common function\") // MODULE: JVM fun whichFun(x: Int) = println(\"platform function\") If you call the whichFun() function in your common code, the function that has the most relevant argument type in the library is resolved: // A project that uses the example library for the JVM target // MODULE: common fun main() { whichFun(2) // platform function } In comparison, if you declare the overloads for whichFun() within the same source set, the function from the common code will be resolved because your code doesn't have access to the platform-specific version: // Example library isn't used // MODULE: common fun whichFun(x: Any) = println(\"common function\") fun main() { whichFun(2) // common function } // MODULE: JVM fun whichFun(x: Int) = println(\"platform function\") Similar to multiplatform libraries, since the commonTest module is in a separate source set, it also still has access to platform-specific code. Therefore, the resolution of calls to functions in the commonTest module exhibits the same behavior as in the old compilation scheme. In the future, these remaining cases will be more consistent with the new compilation scheme. Different visibility levels of expected and actual declarations Before Kotlin 2.0.0, if you used expected and actual declarations in your Kotlin Multiplatform project, they had to have the same visibility level. Kotlin 2.0.0 now also supports different visibility levels but only if the actual declaration is more permissive than the expected declaration. For example: expect internal class Attribute // Visibility is internal actual class Attribute // Visibility is public by default, // which is more permissive Similarly, if you are using a type alias in your actual declaration, the visibility of the underlying type should be the same or more permissive than the expected declaration. For example: expect internal class Attribute // Visibility is internal internal actual typealias Attribute = Expanded class Expanded // Visibility is public by default, // which is more permissive Compiler plugins support Currently, the Kotlin K2 compiler supports the following Kotlin compiler plugins: * all-open * AtomicFU * jvm-abi-gen * js-plain-objects * kapt * Lombok * no-arg * Parcelize * SAM with receiver * serialization * Power-assert In addition, the Kotlin K2 compiler supports: * The Jetpack Compose compiler plugin 2.0.0, which was moved into the Kotlin repository. * The Kotlin Symbol Processing (KSP) plugin since KSP2. If you use any additional compiler plugins, check their documentation to see if they are compatible with K2. Experimental Kotlin Power-assert compiler plugin The Kotlin Power-assert plugin is Experimental. It may be changed at any time. Kotlin 2.0.0 introduces an experimental Power-assert compiler plugin. This plugin improves the experience of writing tests by including contextual information in failure messages, making debugging easier and more efficient. Developers often need to use complex assertion libraries to write effective tests. The Power-assert plugin simplifies this process by automatically generating failure messages that include intermediate values of the assertion expression. This helps developers quickly understand why a test failed. When an assertion fails in a test, the improved error message shows the values of all variables and sub-expressions within the assertion, making it clear which part of the condition caused the failure. This is particularly useful for complex assertions where multiple conditions are checked. To enable the plugin in your project, configure it in your build.gradle(.kts) file: Kotlin Groovy plugins { kotlin(\"multiplatform\") version \"2.0.0\" kotlin(\"plugin.power-assert\") version \"2.0.0\" } powerAssert { functions = listOf(\"kotlin.assert\", \"kotlin.test.assertTrue\") } Learn more about the Kotlin Power-assert plugin in the documentation. How to enable the Kotlin K2 compiler Starting with Kotlin 2.0.0, the Kotlin K2 compiler is enabled by default. No additional actions are required. Try the Kotlin K2 compiler in Kotlin Playground Kotlin Playground supports the 2.0.0 release. Check it out! Support in IDEs By default, IntelliJ IDEA and Android Studio still use the previous compiler for code analysis, code completion, highlighting, and other IDE-related features. To get the full Kotlin 2.0 experience in your IDE, enable K2 mode. In your IDE, go to Settings | Languages & Frameworks | Kotlin and select the Enable K2 mode option. The IDE will analyze your code using its K2 mode. After enabling K2 mode, you may notice differences in IDE analysis due to changes in compiler behavior. Learn how the new K2 compiler differs from the previous one in our migration guide. * Learn more about K2 mode in our blog. * We are actively collecting feedback about K2 mode, so please share your thoughts in our public Slack channel. Leave your feedback on the new K2 compiler We would appreciate any feedback you may have! * Report any problems you face with the new K2 compiler in our issue tracker. * Enable the \"Send usage statistics\" option to allow JetBrains to collect anonymous data about K2 usage. Kotlin/JVM Starting with version 2.0.0, the compiler can generate classes containing Java 22 bytecode. This version also brings the following changes: * Generation of lambda functions using invokedynamic * The kotlinx-metadata-jvm library is now Stable Generation of lambda functions using invokedynamic Kotlin 2.0.0 introduces a new default method for generating lambda functions using invokedynamic. This change reduces the binary sizes of applications compared to the traditional anonymous class generation. Since the first version, Kotlin has generated lambdas as anonymous classes. However, starting from Kotlin 1.5.0, the option for invokedynamic generation has been available by using the -Xlambdas=indy compiler option. In Kotlin 2.0.0, invokedynamic has become the default method for lambda generation. This method produces lighter binaries and aligns Kotlin with JVM optimizations, ensuring applications benefit from ongoing and future improvements in JVM performance. Currently, it has three limitations compared to ordinary lambda compilation: * A lambda compiled into invokedynamic is not serializable. * Experimental reflect() API does not support lambdas generated by invokedynamic. * Calling .toString() on such a lambda produces a less readable string representation: fun main() { println({}) // With Kotlin 1.9.24 and reflection, returns // () -> kotlin.Unit // With Kotlin 2.0.0, returns // FileKt$$Lambda$13/0x00007f88a0004608@506e1b77 } To retain the legacy behavior of generating lambda functions, you can either: * Annotate specific lambdas with @JvmSerializableLambda. * Use the compiler option -Xlambdas=class to generate all lambdas in a module using the legacy method. The kotlinx-metadata-jvm library is Stable In Kotlin 2.0.0, the kotlinx-metadata-jvm library became Stable. Now that the library has changed to the kotlin package and coordinates, you can find it as kotlin-metadata-jvm (without the \"x\"). Previously, the kotlinx-metadata-jvm library had its own publishing scheme and version. Now, we will build and publish the kotlin-metadata-jvm updates as part of the Kotlin release cycle, with the same backward compatibility guarantees as the Kotlin standard library. The kotlin-metadata-jvm library provides an API to read and modify metadata of binary files generated by the Kotlin/JVM compiler. Kotlin/Native This version brings the following changes: * Monitoring GC performance with signposts * Resolving conflicts with Objective-C methods * Changed log level for compiler arguments in Kotlin/Native * Explicitly added standard library and platform dependencies to Kotlin/Native * Tasks error in Gradle configuration cache Monitoring GC performance with signposts on Apple platforms Previously, it was only possible to monitor the performance of Kotlin/Native's garbage collector (GC) by looking into logs. However, these logs were not integrated with Xcode Instruments, a popular toolkit for investigating issues with iOS apps' performance. Since Kotlin 2.0.0, GC reports pauses with signposts that are available in Instruments. Signposts allow for custom logging within your app, so now, when debugging iOS app performance, you can check if a GC pause corresponds to the application freeze. Learn more about GC performance analysis in the documentation. Resolving conflicts with Objective-C methods Objective-C methods can have different names, but the same number and types of parameters. For example, locationManager:didEnterRegion: and locationManager:didExitRegion:. In Kotlin, these methods have the same signature, so an attempt to use them triggers a conflicting overloads error. Previously, you had to manually suppress conflicting overloads to avoid this compilation error. To improve Kotlin interoperability with Objective-C, the Kotlin 2.0.0 introduces the new @ObjCSignatureOverride annotation. The annotation instructs the Kotlin compiler to ignore conflicting overloads, in case several functions with the same argument types but different argument names are inherited from the Objective-C class. Applying this annotation is also safer than general error suppression. This annotation can only be used in the case of overriding Objective-C methods, which are supported and tested, while general suppression may hide important errors and lead to silently broken code. Changed log level for compiler arguments In this release, the log level for compiler arguments in Kotlin/Native Gradle tasks, such as compile, link, and cinterop, has changed from info to debug. With debug as its default value, the log level is consistent with other Gradle compilation tasks and provides detailed debugging information, including all compiler arguments. Explicitly added standard library and platform dependencies to Kotlin/Native Previously, the Kotlin/Native compiler resolved standard library and platform dependencies implicitly, which caused inconsistencies in the way the Kotlin Gradle plugin worked across Kotlin targets. Now, each Kotlin/Native Gradle compilation explicitly includes standard library and platform dependencies in its compile-time library path via the compileDependencyFiles compilation parameter. Tasks error in Gradle configuration cache Since Kotlin 2.0.0, you may encounter a configuration cache error with messages indicating: invocation of Task.project at execution time is unsupported. This error appears in tasks such as NativeDistributionCommonizerTask and KotlinNativeCompile. However, this is a false-positive error. The underlying issue is the presence of tasks that are not compatible with the Gradle configuration cache, like the publish* task. This discrepancy may not be immediately apparent, as the error message suggests a different root cause. As the precise cause isn't explicitly stated in the error report, the Gradle team is already addressing the issue to fix reports. Kotlin/Wasm Kotlin 2.0.0 improves performance and interoperability with JavaScript: * Optimized production builds by default using Binaryen * Support for named export * Support for unsigned primitive types in functions with @JsExport * Generation of TypeScript declaration files in Kotlin/Wasm * Support for catching JavaScript exceptions * New exception handling proposal is now supported as an option * The withWasm() function is split into JS and WASI variants Optimized production builds by default using Binaryen The Kotlin/Wasm toolchain now applies the Binaryen tool during production compilation to all projects, as opposed to the previous manual setup approach. By our estimations, it should improve runtime performance and reduce the binary size for your project. This change only affects production compilation. The development compilation process stays the same. Support for named export Previously, all exported declarations from Kotlin/Wasm were imported into JavaScript using default export: //JavaScript: import Module from \"./index.mjs\" Module.add() Now, you can import each Kotlin declaration marked with @JsExport by name: // Kotlin: @JsExport fun add(a: Int, b: Int) = a + b //JavaScript: import { add } from \"./index.mjs\" Named exports make it easier to share code between Kotlin and JavaScript modules. They improve readability and help you manage dependencies between modules. Support for unsigned primitive types in functions with @JsExport Starting from Kotlin 2.0.0, you can use unsigned primitive types inside external declarations and functions with the @JsExport annotation that makes Kotlin/Wasm functions available in JavaScript code. This helps to mitigate the previous limitation that prevented the unsigned primitives from being used directly inside exported and external declarations. Now you can export functions with unsigned primitives as a return or parameter type and consume external declarations that return or consume unsigned primitives. For more information on Kotlin/Wasm interoperability with JavaScript, see the documentation. Generation of TypeScript declaration files in Kotlin/Wasm Generating TypeScript declaration files in Kotlin/Wasm is Experimental. It may be dropped or changed at any time. In Kotlin 2.0.0, the Kotlin/Wasm compiler is now capable of generating TypeScript definitions from any @JsExport declarations in your Kotlin code. These definitions can be used by IDEs and JavaScript tools to provide code autocompletion, help with type checks, and make it easier to include Kotlin code in JavaScript. The Kotlin/Wasm compiler collects any top-level functions marked with @JsExport and automatically generates TypeScript definitions in a .d.ts file. To generate TypeScript definitions, in your build.gradle(.kts) file in the wasmJs {} block, add the generateTypeScriptDefinitions() function: kotlin { wasmJs { binaries.executable() browser { } generateTypeScriptDefinitions() } } Support for catching JavaScript exceptions Previously, Kotlin/Wasm code could not catch JavaScript exceptions, making it difficult to handle errors originating from the JavaScript side of the program. In Kotlin 2.0.0, we have implemented support for catching JavaScript exceptions within Kotlin/Wasm. This implementation allows you to use try-catch blocks, with specific types like Throwable or JsException, to handle these errors properly. Additionally, finally blocks, which help execute code regardless of exceptions, also work correctly. While we're introducing support for catching JavaScript exceptions, no additional information is provided when a JavaScript exception, like a call stack, occurs. However, we are working on these implementations. New exception handling proposal is now supported as an option In this release, we introduce support for the new version of WebAssembly's exception handling proposal within Kotlin/Wasm. This update ensures the new proposal aligns with Kotlin requirements, enabling the use of Kotlin/Wasm on virtual machines that only support the latest version of the proposal. Activate the new exception handling proposal by using the -Xwasm-use-new-exception-proposal compiler option, which is turned off by default. The withWasm() function is split into JS and WASI variants The withWasm() function, which used to provide Wasm targets for hierarchy templates, is deprecated in favor of specialized withWasmJs() and withWasmWasi() functions. Now you can separate the WASI and JS targets between different groups in the tree definition. Kotlin/JS Among other changes, this version brings modern JS compilation to Kotlin, supporting more features from the ES2015 standard: * New compilation target * Suspend functions as ES2015 generators * Passing arguments to the main function * Per-file compilation for Kotlin/JS projects * Improved collection interoperability * Support for createInstance() * Support for type-safe plain JavaScript objects * Support for npm package manager * Changes to compilation tasks * Discontinuing legacy Kotlin/JS JAR artifacts New compilation target In Kotlin 2.0.0, we're adding a new compilation target to Kotlin/JS, es2015. This is a new way for you to enable all the ES2015 features supported in Kotlin at once. You can set it up in your build.gradle(.kts) file like this: kotlin { js { compilerOptions { target.set(\"es2015\") } } } The new target automatically turns on ES classes and modules and the newly supported ES generators. Suspend functions as ES2015 generators This release introduces Experimental support for ES2015 generators for compiling suspend functions. Using generators instead of state machines should improve the final bundle size of your project. For example, the JetBrains team managed to decrease the bundle size of its Space project by 20% by using the ES2015 generators. Learn more about ES2015 (ECMAScript 2015, ES6) in the official documentation. Passing arguments to the main function Starting with Kotlin 2.0.0, you can specify a source of your args for the main() function. This feature makes it easier to work with the command line and pass the arguments. To do this, define the js {} block with the new passAsArgumentToMainFunction() function, which returns an array of strings: kotlin { js { binary.executable() passAsArgumentToMainFunction(\"Deno.args\") } } The function is executed at runtime. It takes the JavaScript expression and uses it as the args: Array<String> argument instead of the main() function call. Also, if you use the Node.js runtime, you can take advantage of a special alias. It allows you to pass process.argv to the args parameter once instead of adding it manually every time: kotlin { js { binary.executable() nodejs { passProcessArgvToMainFunction() } } } Per-file compilation for Kotlin/JS projects Kotlin 2.0.0 introduces a new granularity option for the Kotlin/JS project output. You can now set up a per-file compilation that generates one JavaScript file for each Kotlin file. It helps to significantly optimize the size of the final bundle and improve the loading time of the program. Previously, there were only two output options. The Kotlin/JS compiler could generate a single .js file for the whole project. However, this file might be too large and inconvenient to use. Whenever you wanted to use a function from your project, you had to include the entire JavaScript file as a dependency. Alternatively, you could configure a compilation of a separate .js file for each project module. This is still the default option. Since module files could also be too large, with Kotlin 2.0.0, we add a more granular output that generates one (or two, if the file contains exported declarations) JavaScript file per each Kotlin file. To enable the per-file compilation mode: * Add the useEsModules() function to your build file to support ECMAScript modules: // build.gradle.kts * kotlin { * js(IR) { * useEsModules() // Enables ES2015 modules * browser() * } * } You can also use the new es2015 compilation target for that. * Apply the -Xir-per-file compiler option or update your gradle.properties file with: # gradle.properties * kotlin.js.ir.output.granularity=per-file // `per-module` is the default Improved collection interoperability Starting with Kotlin 2.0.0, it's possible to export declarations with a Kotlin collection type inside the signature to JavaScript (and TypeScript). This applies to Set, Map, and List collection types and their mutable counterparts. To use Kotlin collections in JavaScript, first mark the necessary declarations with @JsExport annotation: // Kotlin @JsExport data class User( val name: String, val friends: List<User> = emptyList() ) @JsExport val me = User( name = \"Me\", friends = listOf(User(name = \"Kodee\")) ) You can then consume them from JavaScript as regular JavaScript arrays: // JavaScript import { User, me, KtList } from \"my-module\" const allMyFriendNames = me.friends .asJsReadonlyArrayView() .map(x => x.name) // ['Kodee'] Unfortunately, creating Kotlin collections from JavaScript is still unavailable. We're planning to add this functionality in Kotlin 2.0.20. Support for createInstance() Starting with Kotlin 2.0.0, you can use the createInstance() function from the Kotlin/JS target. Previously, it was only available on the JVM. This function from the KClass interface creates a new instance of the specified class, which is useful for getting the runtime reference to a Kotlin class. Support for type-safe plain JavaScript objects The js-plain-objects plugin is Experimental. It may be dropped or changed at any time. The js-plain-objects plugin only supports the K2 compiler. To make it easier to work with JavaScript APIs, in Kotlin 2.0.0, we provide a new plugin: js-plain-objects, which you can use to create type-safe plain JavaScript objects. The plugin checks your code for any external interfaces that have a @JsPlainObject annotation and adds: * An inline invoke operator function inside the companion object that you can use as a constructor. * A .copy() function that you can use to create a copy of your object while adjusting some of its properties. For example: import kotlinx.js.JsPlainObject @JsPlainObject external interface User { var name: String val age: Int val email: String? } fun main() { // Creates a JavaScript object val user = User(name = \"Name\", age = 10) // Copies the object and adds an email val copy = user.copy(age = 11, email = \"some@user.com\") println(JSON.stringify(user)) // { \"name\": \"Name\", \"age\": 10 } println(JSON.stringify(copy)) // { \"name\": \"Name\", \"age\": 11, \"email\": \"some@user.com\" } } Any JavaScript objects created with this approach are safer because instead of only seeing errors at runtime, you can see them at compile time or even highlighted by your IDE. Consider this example, which uses a fetch() function to interact with a JavaScript API using external interfaces to describe the shape of the JavaScript objects: import kotlinx.js.JsPlainObject @JsPlainObject external interface FetchOptions { val body: String? val method: String } // A wrapper for Window.fetch suspend fun fetch(url: String, options: FetchOptions? = null) = TODO(\"Add your custom behavior here\") // A compile-time error is triggered as \"metod\" is not recognized // as method fetch(\"https://google.com\", options = FetchOptions(metod = \"POST\")) // A compile-time error is triggered as method is required fetch(\"https://google.com\", options = FetchOptions(body = \"SOME STRING\")) In comparison, if you use the js() function instead to create your JavaScript objects, errors are only found at runtime or aren't triggered at all: suspend fun fetch(url: String, options: FetchOptions? = null) = TODO(\"Add your custom behavior here\") // No error is triggered. As \"metod\" is not recognized, the wrong method // (GET) is used. fetch(\"https://google.com\", options = js(\"{ metod: 'POST' }\")) // By default, the GET method is used. A runtime error is triggered as // body shouldn't be present. fetch(\"https://google.com\", options = js(\"{ body: 'SOME STRING' }\")) // TypeError: Window.fetch: HEAD or GET Request cannot have a body To use the js-plain-objects plugin, add the following to your build.gradle(.kts) file: Kotlin Groovy plugins { kotlin(\"plugin.js-plain-objects\") version \"2.0.0\" } Support for npm package manager Previously, it was only possible for the Kotlin Multiplatform Gradle plugin to use Yarn as a package manager to download and install npm dependencies. From Kotlin 2.0.0, you can use npm as your package manager instead. Using npm as a package manager means that you have one less tool to manage during your setup. For backward compatibility, Yarn is still the default package manager. To use npm as your package manager, set the following property in your gradle.properties file: kotlin.js.yarn = false Changes to compilation tasks Previously, the webpack and distributeResources compilation tasks both targeted the same directories. Moreover, the distribution task declared the dist as its output directory as well. This resulted in overlapping outputs and produced a compilation warning. So, starting with Kotlin 2.0.0, we've implemented the following changes: * The webpack task now targets a separate folder. * The distributeResources task has been completely removed. * The distribution task now has the Copy type and targets the dist folder. Discontinuing legacy Kotlin/JS JAR artifacts Starting with Kotlin 2.0.0, the Kotlin distribution no longer contains legacy Kotlin/JS artifacts with the .jar extension. Legacy artifacts were used in the unsupported old Kotlin/JS compiler and unnecessary for the IR compiler, which uses the klib format. Gradle improvements Kotlin 2.0.0 is fully compatible with Gradle 6.8.3 through 8.5. You can also use Gradle versions up to the latest Gradle release, but if you do, keep in mind that you might encounter deprecation warnings or some new Gradle features might not work. This version brings the following changes: * New Gradle DSL for compiler options in multiplatform projects * New Compose compiler Gradle plugin * New attribute to distinguish JVM and Android published libraries * Improved Gradle dependency handling for CInteropProcess in Kotlin/Native * Visibility changes in Gradle * New directory for Kotlin data in Gradle projects * Kotlin/Native compiler downloaded when needed * Deprecating old ways of defining compiler options * Bumped minimum AGP supported version * New Gradle property for trying the latest language version * New JSON output format for build reports * kapt configurations inherit annotation processors from superconfigurations * Kotlin Gradle plugin no longer uses deprecated Gradle conventions New Gradle DSL for compiler options in multiplatform projects This feature is Experimental. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate your feedback on it in YouTrack. Prior to Kotlin 2.0.0, configuring compiler options in a multiplatform project with Gradle was only possible at a low level, such as per task, compilation, or source set. To make it easier to configure compiler options more generally in your projects, Kotlin 2.0.0 comes with a new Gradle DSL. With this new DSL, you can configure compiler options at the extension level for all the targets and shared source sets like commonMain and at a target level for a specific target: kotlin { compilerOptions { // Extension-level common compiler options that are used as defaults // for all targets and shared source sets allWarningsAsErrors.set(true) } jvm { compilerOptions { // Target-level JVM compiler options that are used as defaults // for all compilations in this target noJdk.set(true) } } } The overall project configuration now has three layers. The highest is the extension level, then the target level and the lowest is the compilation unit (which is usually a compilation task): The settings at a higher level are used as a convention (default) for a lower level: * The values of extension compiler options are the default for target compiler options, including shared source sets, like commonMain, nativeMain, and commonTest. * The values of target compiler options are used as the default for compilation unit (task) compiler options, for example, compileKotlinJvm and compileTestKotlinJvm tasks. In turn, configurations made at a lower level override related settings at a higher level: * Task-level compiler options override related configurations at the target or the extension level. * Target-level compiler options override related configurations at the extension level. When configuring your project, keep in mind that some old ways of setting up compiler options have been deprecated. We encourage you to try the new DSL out in your multiplatform projects and leave feedback in YouTrack, as we plan to make this DSL the recommended approach for configuring compiler options. New Compose compiler Gradle plugin The Jetpack Compose compiler, which translates composables into Kotlin code, has now been merged into the Kotlin repository. This will help transition Compose projects to Kotlin 2.0.0, as the Compose compiler will always ship simultaneously with Kotlin. This also bumps the Compose compiler version to 2.0.0. To use the new Compose compiler in your projects, apply the org.jetbrains.kotlin.plugin.compose Gradle plugin in your build.gradle(.kts) file and set its version equal to Kotlin 2.0.0. To learn more about this change and see the migration instructions, see the Compose compiler documentation. New attribute to distinguish JVM and Android-published libraries Starting with Kotlin 2.0.0, the org.gradle.jvm.environment Gradle attribute is published by default with all Kotlin variants. The attribute helps distinguish JVM and Android variants of Kotlin Multiplatform libraries. It indicates that a certain library variant is better suited for a certain JVM environment. The target environment could be \"android\", \"standard-jvm\", or \"no-jvm\". Publishing this attribute should make consuming Kotlin Multiplatform libraries with JVM and Android targets more robust from non-multiplatform clients as well, such as Java-only projects. If necessary, you can disable attribute publication. To do that, add the following Gradle option to your gradle.properties file: kotlin.publishJvmEnvironmentAttribute=false Improved Gradle dependency handling for CInteropProcess in Kotlin/Native In this release, we enhanced the handling of the defFile property to ensure better Gradle task dependency management in Kotlin/Native projects. Before this update, Gradle builds could fail if the defFile property was designated as an output of another task that hadn't been executed yet. The workaround for this issue was to add a dependency on this task: kotlin { macosArm64(\"native\") { compilations.getByName(\"main\") { cinterops { val cinterop by creating { defFileProperty.set(createDefFileTask.flatMap { it.defFile.asFile }) project.tasks.named(interopProcessingTaskName).configure { dependsOn(createDefFileTask) } } } } } } To fix this, there is a new RegularFileProperty property called definitionFile. Now, Gradle lazily verifies the presence of the definitionFile property after the connected task has run later in the build process. This new approach eliminates the need for additional dependencies. The CInteropProcess task and the CInteropSettings class use the definitionFile property instead of defFile and defFileProperty: Kotlin Groovy kotlin { macosArm64(\"native\") { compilations.getByName(\"main\") { cinterops { val cinterop by creating { definitionFile.set(project.file(\"def-file.def\")) } } } } } defFile and defFileProperty parameters are deprecated. Visibility changes in Gradle This change impacts only Kotlin DSL users. In Kotlin 2.0.0, we've modified the Kotlin Gradle Plugin for better control and safety in your build scripts. Previously, certain Kotlin DSL functions and properties intended for a specific DSL context would inadvertently leak into other DSL contexts. This leakage could lead to the use of incorrect compiler options, settings being applied multiple times, and other misconfigurations: kotlin { // Target DSL couldn't access methods and properties defined in the // kotlin{} extension DSL jvm { // Compilation DSL couldn't access methods and properties defined // in the kotlin{} extension DSL and Kotlin jvm{} target DSL compilations.configureEach { // Compilation task DSLs couldn't access methods and // properties defined in the kotlin{} extension, Kotlin jvm{} // target or Kotlin compilation DSL compileTaskProvider.configure { // For example: explicitApi() // ERROR as it is defined in the kotlin{} extension DSL mavenPublication {} // ERROR as it is defined in the Kotlin jvm{} target DSL defaultSourceSet {} // ERROR as it is defined in the Kotlin compilation DSL } } } } To fix this issue, we've added the @KotlinGradlePluginDsl annotation, preventing the exposure of the Kotlin Gradle plugin DSL functions and properties to levels where they are not intended to be available. The following levels are separated from each other: * Kotlin extension * Kotlin target * Kotlin compilation * Kotlin compilation task For the most popular cases, we've added compiler warnings with suggestions on how to fix them if your build script is configured incorrectly. For example: kotlin { jvm { sourceSets.getByName(\"jvmMain\").dependencies { implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core-jvm:1.7.3\") } } } In this case, the warning message for sourceSets is: [DEPRECATION] 'sourceSets: NamedDomainObjectContainer<KotlinSourceSet>' is deprecated.Accessing 'sourceSets' container on the Kotlin target level DSL is deprecated. Consider configuring 'sourceSets' on the Kotlin extension level. We would appreciate your feedback on this change! Share your comments directly to Kotlin developers in our #gradle Slack channel. Get a Slack invite. New directory for Kotlin data in Gradle projects Do not commit the .kotlin directory to version control. For example, if you are using Git, add .kotlin to your project's .gitignore file. In Kotlin 1.8.20, the Kotlin Gradle plugin switched to storing its data in the Gradle project cache directory: <project-root-directory>/.gradle/kotlin. However, the .gradle directory is reserved for Gradle only, and as a result it's not future-proof. To solve this, as of Kotlin 2.0.0, we will store Kotlin data in your <project-root-directory>/.kotlin by default. We will continue to store some data in the .gradle/kotlin directory for backward compatibility. The new Gradle properties you can configure are: Gradle property Description kotlin.project.persistent.dir Configures the location where your project-level data is stored. Default: <project-root-directory>/.kotlin kotlin.project.persistent.dir.gradle.disableWrite A boolean value that controls whether writing Kotlin data to the .gradle directory is disabled. Default: false Add these properties to the gradle.properties file in your projects for them to take effect. Kotlin/Native compiler downloaded when needed Before Kotlin 2.0.0, if you had a Kotlin/Native target configured in the Gradle build script of your multiplatform project, Gradle would always download the Kotlin/Native compiler in the configuration phase. This happened even if there was no task to compile code for a Kotlin/Native target that was due to run in the execution phase. Downloading the Kotlin/Native compiler in this way was particularly inefficient for users who only wanted to check the JVM or JavaScript code in their projects. For example, to perform tests or checks with their Kotlin project as part of a CI process. In Kotlin 2.0.0, we changed this behavior in the Kotlin Gradle plugin so that the Kotlin/Native compiler is downloaded in the execution phase and only when a compilation is requested for a Kotlin/Native target. In turn, the Kotlin/Native compiler's dependencies are now downloaded not as a part of the compiler, but in the execution phase as well. If you encounter any issues with the new behavior, you can temporarily switch back to the previous behavior by adding the following Gradle property to your gradle.properties file: kotlin.native.toolchain.enabled=false Starting with Kotlin 1.9.20-Beta, the Kotlin/Native distribution is published to Maven Central along with the CDN. This allowed us to change how Kotlin looks for and downloads the necessary artifacts. Instead of the CDN, by default, it now uses the Maven repositories that you specified in the repositories {} block of your project. You can temporarily switch this behavior back by setting the following Gradle property in your gradle.properties file: kotlin.native.distribution.downloadFromMaven=false Please report any problems to our issue tracker YouTrack. Both of these Gradle properties that change the default behavior are temporary and will be removed in future releases. Deprecated old ways of defining compiler options In this release, we continue to refine how you can set up compiler options. It should resolve ambiguity between different ways and make the project configuration more straightforward. Since Kotlin 2.0.0, the following DSLs for specifying compiler options are deprecated: * The kotlinOptions DSL from the KotlinCompile interface that implements all Kotlin compilation tasks. Use KotlinCompilationTask<CompilerOptions> instead. * The compilerOptions property with the HasCompilerOptions type from the KotlinCompilation interface. This DSL was inconsistent with other DSLs and configured the same KotlinCommonCompilerOptions object as compilerOptions inside the KotlinCompilation.compileTaskProvider compilation task, which was confusing. Instead, we recommend using the compilerOptions property from the Kotlin compilation task: kotlinCompilation.compileTaskProvider.configure { * compilerOptions { ... } * } For example: kotlin { * js(IR) { * compilations.all { * compileTaskProvider.configure { * compilerOptions.freeCompilerArgs.add(\"-Xir-minimized-member-names=false\") * } * } * } * } * The kotlinOptions DSL from the KotlinCompilation interface. * The kotlinOptions DSL from the KotlinNativeArtifactConfig interface, the KotlinNativeLink class, and the KotlinNativeLinkArtifactTask class. Use the toolOptions DSL instead. * The dceOptions DSL from the KotlinJsDce interface. Use the toolOptions DSL instead. For more information on how to specify compiler options in the Kotlin Gradle plugin, see How to define options. Bumped minimum supported AGP version Starting with Kotlin 2.0.0, the minimum supported Android Gradle plugin version is 7.1.3. New Gradle property for trying the latest language version Prior to Kotlin 2.0.0, we had the following Gradle property to try out the new K2 compiler: kotlin.experimental.tryK2. Now that the K2 compiler is enabled by default in Kotlin 2.0.0, we decided to evolve this property into a new form that you can use to try the latest language version in your projects: kotlin.experimental.tryNext. When you use this property in your gradle.properties file, the Kotlin Gradle plugin increments the language version to one above the default value for your Kotlin version. For example, in Kotlin 2.0.0, the default language version is 2.0, so the property configures language version 2.1. This new Gradle property produces similar metrics in build reports as before with kotlin.experimental.tryK2. The language version configured is included in the output. For example: ##### 'kotlin.experimental.tryNext' results ##### :app:compileKotlin: 2.1 language version :lib:compileKotlin: 2.1 language version ##### 100% (2/2) tasks have been compiled with Kotlin 2.1 ##### To learn more about how to enable build reports and their content, see Build reports. New JSON output format for build reports In Kotlin 1.7.0, we introduced build reports to help track compiler performance. Over time, we've added more metrics to make these reports even more detailed and helpful when investigating performance issues. Previously, the only output format for a local file was the *.txt format. In Kotlin 2.0.0, we support the JSON output format to make it even easier to analyze using other tools. To configure JSON output format for your build reports, declare the following properties in your gradle.properties file: kotlin.build.report.output=json // The directory to store your build reports kotlin.build.report.json.directory=my/directory/path Alternatively, you can run the following command: ./gradlew assemble -Pkotlin.build.report.output=json -Pkotlin.build.report.json.directory=\"my/directory/path\" Once configured, Gradle generates your build reports in the directory that you specify with the name: ${project_name}-date-time-<sequence_number>.json. Here's an example snippet from a build report with JSON output format that contains build metrics and aggregated metrics: \"buildOperationRecord\": [ { \"path\": \":lib:compileKotlin\", \"classFqName\": \"org.jetbrains.kotlin.gradle.tasks.KotlinCompile_Decorated\", \"startTimeMs\": 1714730820601, \"totalTimeMs\": 2724, \"buildMetrics\": { \"buildTimes\": { \"buildTimesNs\": { \"CLEAR_OUTPUT\": 713417, \"SHRINK_AND_SAVE_CURRENT_CLASSPATH_SNAPSHOT_AFTER_COMPILATION\": 19699333, \"IR_TRANSLATION\": 281000000, \"NON_INCREMENTAL_LOAD_CURRENT_CLASSPATH_SNAPSHOT\": 14088042, \"CALCULATE_OUTPUT_SIZE\": 1301500, \"GRADLE_TASK\": 2724000000, \"COMPILER_INITIALIZATION\": 263000000, \"IR_GENERATION\": 74000000, ... } } ... \"aggregatedMetrics\": { \"buildTimes\": { \"buildTimesNs\": { \"CLEAR_OUTPUT\": 782667, \"SHRINK_AND_SAVE_CURRENT_CLASSPATH_SNAPSHOT_AFTER_COMPILATION\": 22031833, \"IR_TRANSLATION\": 333000000, \"NON_INCREMENTAL_LOAD_CURRENT_CLASSPATH_SNAPSHOT\": 14890292, \"CALCULATE_OUTPUT_SIZE\": 2370750, \"GRADLE_TASK\": 3234000000, \"COMPILER_INITIALIZATION\": 292000000, \"IR_GENERATION\": 89000000, ... } } kapt configurations inherit annotation processors from superconfigurations Prior to Kotlin 2.0.0, if you wanted to define a common set of annotation processors in a separate Gradle configuration and extend this configuration in kapt-specific configurations for your subprojects, kapt would skip annotation processing because it couldn't find any annotation processors. In Kotlin 2.0.0, kapt can successfully detect that there are indirect dependencies on your annotation processors. As an example, for a subproject using Dagger, in your build.gradle(.kts) file, use the following configuration: val commonAnnotationProcessors by configurations.creating configurations.named(\"kapt\") { extendsFrom(commonAnnotationProcessors) } dependencies { implementation(\"com.google.dagger:dagger:2.48.1\") commonAnnotationProcessors(\"com.google.dagger:dagger-compiler:2.48.1\") } In this example, the commonAnnotationProcessors Gradle configuration is your common configuration for annotation processing that you want to be used for all your projects. You use the extendsFrom() method to add commonAnnotationProcessors as a superconfiguration. kapt sees that the commonAnnotationProcessors Gradle configuration has a dependency on the Dagger annotation processor. Therefore, kapt includes the Dagger annotation processor in its configuration for annotation processing. Thanks to Christoph Loy for the implementation! Kotlin Gradle plugin no longer uses deprecated Gradle conventions Prior to Kotlin 2.0.0, if you used Gradle 8.2 or higher, the Kotlin Gradle plugin incorrectly used Gradle conventions that had been deprecated in Gradle 8.2. This led to Gradle reporting build deprecations. In Kotlin 2.0.0, the Kotlin Gradle plugin has been updated to no longer trigger these deprecation warnings when you use Gradle 8.2 or higher. Standard library This release brings further stability to the Kotlin standard library and makes even more existing functions common for all platforms: * Stable replacement of the enum class values generic function * Stable AutoCloseable interface * Common protected property AbstractMutableList.modCount * Common protected function AbstractMutableList.removeRange * Common String.toCharArray(destination) Stable replacement of the enum class values generic function In Kotlin 2.0.0, the enumEntries<T>() function becomes Stable. The enumEntries<T>() function is a replacement for the generic enumValues<T>() function. The new function returns a list of all enum entries for the given enum type T. The entries property for enum classes was previously introduced and also stabilized to replace the synthetic values() function. For more information about the entries property, see What's new in Kotlin 1.8.20. The enumValues<T>() function is still supported, but we recommend that you use the enumEntries<T>() function instead because it has less of a performance impact. Every time you call enumValues<T>(), a new array is created, whereas whenever you call enumEntries<T>(), the same list is returned each time, which is far more efficient. For example: enum class RGB { RED, GREEN, BLUE } inline fun <reified T : Enum<T>> printAllValues() { print(enumEntries<T>().joinToString { it.name }) } printAllValues<RGB>() // RED, GREEN, BLUE Stable AutoCloseable interface In Kotlin 2.0.0, the common AutoCloseable interface becomes Stable. It allows you to easily close resources and includes a couple of useful functions: * The use() extension function, which executes a given block function on the selected resource and then closes it down correctly, whether an exception is thrown or not. * The AutoCloseable() constructor function, which creates instances of the AutoCloseable interface. In the example below, we define the XMLWriter interface and assume that there is a resource that implements it. For example, this resource could be a class that opens a file, writes XML content, and then closes it: interface XMLWriter { fun document(encoding: String, version: String, content: XMLWriter.() -> Unit) fun element(name: String, content: XMLWriter.() -> Unit) fun attribute(name: String, value: String) fun text(value: String) fun flushAndClose() } fun writeBooksTo(writer: XMLWriter) { val autoCloseable = AutoCloseable { writer.flushAndClose() } autoCloseable.use { writer.document(encoding = \"UTF-8\", version = \"1.0\") { element(\"bookstore\") { element(\"book\") { attribute(\"category\", \"fiction\") element(\"title\") { text(\"Harry Potter and the Prisoner of Azkaban\") } element(\"author\") { text(\"J. K. Rowling\") } element(\"year\") { text(\"1999\") } element(\"price\") { text(\"29.99\") } } element(\"book\") { attribute(\"category\", \"programming\") element(\"title\") { text(\"Kotlin in Action\") } element(\"author\") { text(\"Dmitry Jemerov\") } element(\"author\") { text(\"Svetlana Isakova\") } element(\"year\") { text(\"2017\") } element(\"price\") { text(\"25.19\") } } } } } } Common protected property AbstractMutableList.modCount In this release, the modCount protectedproperty of the AbstractMutableList interface becomes common. Previously, the modCount property was available on each platform but not for the common target. Now, you can create custom implementations of AbstractMutableList and access the property in common code. The property keeps track of the number of structural modifications made to the collection. This includes operations that change the collection size or alter the list in a way that may cause iterations in progress to return incorrect results. You can use the modCount property to register and detect concurrent modifications when implementing a custom list. Common protected function AbstractMutableList.removeRange In this release, the removeRange() protectedfunction of the AbstractMutableList interface becomes common. Previously, it was available on each platform but not for the common target. Now, you can create custom implementations of AbstractMutableList and override the function in common code. The function removes elements from this list following the specified range. By overriding this function, you can take advantage of the custom implementations and improve the performance of the list operation. Common String.toCharArray(destination) function This release introduces a common String.toCharArray(destination) function. Previously, it was only available on the JVM. Let's compare it with the existing String.toCharArray() function. It creates a new CharArray that contains characters from the specified string. The new common String.toCharArray(destination) function, however, moves String characters into an existing destination CharArray. This is useful if you already have a buffer that you want to fill: fun main() { val myString = \"Kotlin is awesome!\" val destinationArray = CharArray(myString.length) ​ // Convert the string and store it in the destinationArray: myString.toCharArray(destinationArray) ​ for (char in destinationArray) { print(\"$char \") // K o t l i n i s a w e s o m e ! } } Open in Playground → Target: JVM Running on v.2.3.0 Install Kotlin 2.0.0 Starting from IntelliJ IDEA 2023.3 and Android Studio Iguana (2023.2.1) Canary 15, the Kotlin plugin is distributed as a bundled plugin included in your IDE. This means that you can't install the plugin from JetBrains Marketplace anymore. To update to the new Kotlin version, change the Kotlin version to 2.0.0 in your build scripts.",
        "crawl_status": "success"
      },
      {
        "library_name": "Kotlin",
        "url": "https://kotlinlang.org/docs/whatsnew22.html",
        "version": "Unknown version",
        "title": "What's new in Kotlin 2.2.0 | Kotlin Documentation",
        "release_date": "Unknown release date",
        "content": "What's new in Kotlin 2.2.0 Edit page13 November 2025 Released: June 23, 2025 The Kotlin 2.2.0 release is here! Here are the main highlights: * Language: new language features in preview, including context parameters. Several previously experimental features are now Stable, such as guard conditions, non-local break and continue, and multi-dollar interpolation. * Kotlin compiler: unified management of compiler warnings. * Kotlin/JVM: changes to default method generation for interface functions. * Kotlin/Native: LLVM 19 and new features for tracking and adjusting memory consumption. * Kotlin/Wasm: separated Wasm target and the ability to configure Binaryen per project. * Kotlin/JS: fix for the copy() method generated for @JsPlainObject interfaces. * Gradle: binary compatibility validation in the Kotlin Gradle plugin. * Standard library: stable Base64 and HexFormat APIs. * Documentation: our documentation survey is open, and notable improvements have been made to the Kotlin documentation. You can also watch this video of the Kotlin Language Evolution team discussing new features and answering questions: IDE support The Kotlin plugins that support 2.2.0 are bundled in the latest versions of IntelliJ IDEA and Android Studio. You don't need to update the Kotlin plugin in your IDE. All you need to do is to change the Kotlin version to 2.2.0 in your build scripts. See Update to a new release for details. Language This release promotes guard conditions, non-local break and continue, and multi-dollar interpolation to Stable. Additionally, several features, such as context parameters and context-sensitive resolution, are introduced in preview. Experimental Preview of context parameters Context parameters allow functions and properties to declare dependencies that are implicitly available in the surrounding context. With context parameters, you don't need to manually pass around values, such as services or dependencies, that are shared and rarely change across sets of function calls. Context parameters replace an older experimental feature called context receivers. To migrate from context receivers to context parameters, you can use assisted support in IntelliJ IDEA, as described in the blog post. The main difference is that context parameters are not introduced as receivers in the body of a function. As a result, you need to use the name of the context parameters to access their members, unlike with context receivers, where the context is implicitly available. Context parameters in Kotlin represent a significant improvement in managing dependencies through simplified dependency injection, improved DSL design, and scoped operations. For more information, see the feature's KEEP. How to declare context parameters You can declare context parameters for properties and functions using the context keyword followed by a list of parameters, each of the form name: Type. Here is an example with a dependency on the UserService interface: // UserService defines the dependency required in the context interface UserService { fun log(message: String) fun findUserById(id: Int): String } // Declares a function with a context parameter context(users: UserService) fun outputMessage(message: String) { // Uses log from the context users.log(\"Log: $message\") } // Declares a property with a context parameter context(users: UserService) val firstUser: String // Uses findUserById from the context get() = users.findUserById(1) You can use _ as a context parameter name. In this case, the parameter's value is available for resolution but is not accessible by name inside the block: // Uses \"_\" as context parameter name context(_: UserService) fun logWelcome() { // Finds the appropriate log function from UserService outputMessage(\"Welcome!\") } How to enable context parameters To enable context parameters in your project, use the following compiler option in the command line: -Xcontext-parameters Or add it to the compilerOptions {} block of your Gradle build file: // build.gradle.kts kotlin { compilerOptions { freeCompilerArgs.add(\"-Xcontext-parameters\") } } Specifying both -Xcontext-receivers and -Xcontext-parameters compiler options simultaneously leads to an error. Leave your feedback This feature is planned to be stabilized and improved in future Kotlin releases. We would appreciate your feedback on our issue tracker, YouTrack. Experimental Preview of context-sensitive resolution Kotlin 2.2.0 introduces an implementation of context-sensitive resolution in preview. You can find an overview of this feature in this video: Previously, you had to write the full name of enum entries or sealed class members, even when the type could be inferred from the context. For example: enum class Problem { CONNECTION, AUTHENTICATION, DATABASE, UNKNOWN } fun message(problem: Problem): String = when (problem) { Problem.CONNECTION -> \"connection\" Problem.AUTHENTICATION -> \"authentication\" Problem.DATABASE -> \"database\" Problem.UNKNOWN -> \"unknown\" } Now, with context-sensitive resolution, you can omit the type name in contexts where the expected type is known: enum class Problem { CONNECTION, AUTHENTICATION, DATABASE, UNKNOWN } // Resolves enum entries based on the known type of problem fun message(problem: Problem): String = when (problem) { CONNECTION -> \"connection\" AUTHENTICATION -> \"authentication\" DATABASE -> \"database\" UNKNOWN -> \"unknown\" } The compiler uses this contextual type information to resolve the correct member. This information includes, among other things: * The subject of a when expression * An explicit return type * A declared variable type * Type checks (is) and casts (as) * The known type of a sealed class hierarchy * The declared type of a parameter Context-sensitive resolution doesn't apply to functions, properties with parameters, or extension properties with receivers. To try out context-sensitive resolution in your project, use the following compiler option in the command line: -Xcontext-sensitive-resolution Or add it to the compilerOptions {} block of your Gradle build file: // build.gradle.kts kotlin { compilerOptions { freeCompilerArgs.add(\"-Xcontext-sensitive-resolution\") } } We plan to stabilize and improve this feature in future Kotlin releases and would appreciate your feedback on our issue tracker YouTrack. Experimental Preview of features for annotation use-site targets Kotlin 2.2.0 introduces a couple of features that make working with annotation use-site targets more convenient. Experimental @all meta-target for properties Kotlin allows you to attach annotations to specific parts of a declaration, known as use-site targets. However, annotating each target individually was complex and error-prone: data class User( val username: String, @param:Email // Constructor parameter @field:Email // Backing field @get:Email // Getter method @property:Email // Kotlin property reference val email: String, ) { @field:Email @get:Email @property:Email val secondaryEmail: String? = null } To simplify this, Kotlin introduces the new @all meta-target for properties. This feature tells the compiler to apply the annotation to all relevant parts of the property. When you use it, @all attempts to apply the annotation to: * param: the constructor parameter, if declared in the primary constructor. * property: the Kotlin property itself. * field: the backing field, if it exists. * get: the getter method. * setparam: the parameter of the setter method, if the property is defined as var. * RECORD_COMPONENT: if the class is a @JvmRecord, the annotation applies to the Java record component. This behavior mimics the way Java handles annotations on record components. The compiler only applies the annotation to the targets for the given property. In the example below, the @Email annotation is applied to all relevant targets of each property: data class User( val username: String, // Applies @Email to param, property, field, // get, and setparam (if var) @all:Email val email: String, ) { // Applies @Email to property, field, and get // (no param since it's not in the constructor) @all:Email val secondaryEmail: String? = null } You can use the @all meta-target with any property, both inside and outside the primary constructor. However, you can't use the @all meta-target with multiple annotations. This new feature simplifies the syntax, ensures consistency, and improves interoperability with Java records. To enable the @all meta-target in your project, use the following compiler option in the command line: -Xannotation-target-all Or add it to the compilerOptions {} block of your Gradle build file: // build.gradle.kts kotlin { compilerOptions { freeCompilerArgs.add(\"-Xannotation-target-all\") } } This feature is in preview. Please report any problems to our issue tracker, YouTrack. For more information about the @all meta-target, read this KEEP proposal. Experimental New defaulting rules for use-site annotation targets Kotlin 2.2.0 introduces new defaulting rules for propagating annotations to parameters, fields, and properties. Where previously an annotation was applied by default only to one of param, property, or field, defaults are now more in line with what is expected of an annotation. If there are multiple applicable targets, one or more is chosen as follows: * If the constructor parameter target (param) is applicable, it is used. * If the property target (property) is applicable, it is used. * If the field target (field) is applicable while property isn't, field is used. If there are multiple targets, and none of param, property, or field are applicable, the annotation results in an error. To enable this feature, add it to the compilerOptions {} block of your Gradle build file: // build.gradle.kts kotlin { compilerOptions { freeCompilerArgs.add(\"-Xannotation-default-target=param-property\") } } Or use the command-line argument for the compiler: -Xannotation-default-target=param-property Whenever you'd like to use the old behavior, you can: * In a specific case, define the necessary target explicitly, for example, using @param:Annotation instead of @Annotation. * For a whole project, use this flag in your Gradle build file: // build.gradle.kts * kotlin { * compilerOptions { * freeCompilerArgs.add(\"-Xannotation-default-target=first-only\") * } * } This feature is in preview. Please report any problems to our issue tracker, YouTrack. For more information about the new defaulting rules for annotation use-site targets, read this KEEP proposal. Beta Support for nested type aliases Kotlin 2.2.0 adds support for defining type aliases inside other declarations. You can find an overview of this feature in this video: Previously, you could only declare type aliases at the top level of a Kotlin file. This meant that even internal or domain-specific type aliases had to live outside the class where they were used. Starting from 2.2.0, you can define type aliases inside other declarations, as long as they don't capture type parameters from their outer class: class Dijkstra { typealias VisitedNodes = Set<Node> private fun step(visited: VisitedNodes, ...) = ... } Nested type aliases have a few additional constraints, like not being able to mention type parameters. Check the documentation for the entire set of rules. Nested type aliases allow for cleaner, more maintainable code by improving encapsulation, reducing package-level clutter, and simplifying internal implementations. How to enable nested type aliases To enable nested type aliases in your project, use the following compiler option in the command line: -Xnested-type-aliases Or add it to the compilerOptions {} block of your Gradle build file: // build.gradle.kts kotlin { compilerOptions { freeCompilerArgs.add(\"-Xnested-type-aliases\") } } Share your feedback Nested type aliases are currently in Beta. Please report any problems to our issue tracker, YouTrack. For more information about this feature, read this KEEP proposal. Stable features: guard conditions, non-local break and continue, and multi-dollar interpolation In Kotlin 2.1.0, several new language features were introduced in preview. We're happy to announce that the following language features are now Stable in this release: * Guard conditions in when with a subject * Non-local break and continue * Multi-dollar interpolation: improved handling of $ in string literals See the full list of Kotlin language design features and proposals. Experimental Kotlin compiler: unified management of compiler warnings Kotlin 2.2.0 introduces a new compiler option, -Xwarning-level. It's designed to provide a unified way of managing compiler warnings in Kotlin projects. Previously, you could only apply general module-wide rules, like disabling all warnings with -nowarn, turning all warnings to compilation errors with -Werror, or enabling additional compiler checks with -Wextra. The only option to adjust them for specific warnings was the -Xsuppress-warning option. With the new solution, you can override general rules and exclude specific diagnostics in a consistent way. How to apply The new compiler option has the following syntax: -Xwarning-level=DIAGNOSTIC_NAME:(error|warning|disabled) * error: raises the specified warning to an error. * warning: emits a warning and is enabled by default. * disabled: completely suppresses the specified warning module-wide. Keep in mind that you can only configure the severity level of warnings with the new compiler option. Use cases With the new solution, you can better fine-tune warning reporting in your project by combining general rules with specific ones. Choose your use case: Suppress warnings Command Description -nowarn Suppresses all warnings during compilation. -Xwarning-level=DIAGNOSTIC_NAME:disabled Suppresses only specified warnings. -nowarn -Xwarning-level=DIAGNOSTIC_NAME:warning Suppresses all warnings except for the specified ones. Raise warnings to errors Command Description -Werror Raises all warnings to compilation errors. -Xwarning-level=DIAGNOSTIC_NAME:error Raises only specified warnings to errors. -Werror -Xwarning-level=DIAGNOSTIC_NAME:warning Raises all warnings to errors except for the specified ones. Enable additional compiler warnings Command Description -Wextra Enables all additional declaration, expression, and type compiler checks that emit warnings if true. -Xwarning-level=DIAGNOSTIC_NAME:warning Enables only specified additional compiler checks. -Wextra -Xwarning-level=DIAGNOSTIC_NAME:disabled Enables all additional checks except for the specified ones. Warning lists In case you have many warnings you want to exclude from general rules, you can list them in a separate file through @argfile. Leave feedback The new compiler option is still Experimental. Please report any problems to our issue tracker, YouTrack. Kotlin/JVM Kotlin 2.2.0 brings many updates to the JVM. The compiler now supports Java 24 bytecode and introduces changes to default method generation for interface functions. The release also simplifies working with annotations in Kotlin metadata, improves Java interop with inline value classes, and includes better support for annotating JVM records. Changes to default method generation for interface functions Starting from Kotlin 2.2.0, functions declared in interfaces are compiled to JVM default methods unless configured otherwise. This change affects how Kotlin's interface functions with implementations are compiled to bytecode. This behavior is controlled by the new stable compiler option -jvm-default, replacing the deprecated -Xjvm-default option. You can control the behavior of the -jvm-default option using the following values: * enable (default): generates default implementations in interfaces and includes bridge functions in subclasses and DefaultImpls classes. Use this mode to maintain binary compatibility with older Kotlin versions. * no-compatibility: generates only default implementations in interfaces. This mode skips compatibility bridges and DefaultImpls classes, making it suitable for new code. * disable: disables default implementations in interfaces. Only bridge functions and DefaultImpls classes are generated, matching the behavior before Kotlin 2.2.0. To configure the -jvm-default compiler option, set the jvmDefault property in your Gradle Kotlin DSL: // build.gradle.kts kotlin { compilerOptions { jvmDefault = JvmDefaultMode.NO_COMPATIBILITY } } Experimental Support for reading and writing annotations in Kotlin metadata Previously, you had to read annotations from compiled JVM class files using reflection or bytecode analysis and manually match them to metadata entries based on signatures. This process was error-prone, especially for overloaded functions. Now, in Kotlin 2.2.0, the Kotlin Metadata JVM library introduces support for reading annotations stored in Kotlin metadata. To make annotations available in the metadata for your compiled files, add the following compiler option: -Xannotations-in-metadata Alternatively, add it to the compilerOptions {} block of your Gradle build file: // build.gradle.kts kotlin { compilerOptions { freeCompilerArgs.add(\"-Xannotations-in-metadata\") } } With this option enabled, the Kotlin compiler writes annotations into metadata alongside the JVM bytecode, making them accessible to the kotlin-metadata-jvm library. The library provides the following APIs for accessing annotations: * KmClass.annotations * KmFunction.annotations * KmProperty.annotations * KmConstructor.annotations * KmPropertyAccessorAttributes.annotations * KmValueParameter.annotations * KmFunction.extensionReceiverAnnotations * KmProperty.extensionReceiverAnnotations * KmProperty.backingFieldAnnotations * KmProperty.delegateFieldAnnotations * KmEnumEntry.annotations These APIs are Experimental. To opt in, use the @OptIn(ExperimentalAnnotationsInMetadata::class) annotation. Here's an example of reading annotations from Kotlin metadata: @file:OptIn(ExperimentalAnnotationsInMetadata::class) import kotlin.metadata.ExperimentalAnnotationsInMetadata import kotlin.metadata.jvm.KotlinClassMetadata annotation class Label(val value: String) @Label(\"Message class\") class Message fun main() { val metadata = Message::class.java.getAnnotation(Metadata::class.java) val kmClass = (KotlinClassMetadata.readStrict(metadata) as KotlinClassMetadata.Class).kmClass println(kmClass.annotations) // [@Label(value = StringValue(\"Message class\"))] } If you use the kotlin-metadata-jvm library in your projects, we recommend testing and updating your code to support annotations. Otherwise, when annotations in metadata become enabled by default in a future Kotlin version, your projects may produce invalid or incomplete metadata. If you experience any problems, please report them in our issue tracker. Experimental Improved Java interop with inline value classes Kotlin 2.2.0 introduces a new experimental annotation: @JvmExposeBoxed. This annotation makes it easier to consume inline value classes from Java. You can find an overview of this feature in this video: By default, Kotlin compiles inline value classes to use unboxed representations, which are more performant but often hard or even impossible to use from Java. For example: @JvmInline value class PositiveInt(val number: Int) { init { require(number >= 0) } } In this case, because the class is unboxed, there is no constructor available for Java to call. There's also no way for Java to trigger the init block to ensure that number is positive. When you annotate the class with @JvmExposeBoxed, Kotlin generates a public constructor that Java can call directly, ensuring that the init block also runs. You can apply the @JvmExposeBoxed annotation at the class, constructor, or function level to gain fine-grained control over what's exposed to Java. For example, in the following code, the extension function .timesTwoBoxed() is not accessible from Java: @JvmInline value class MyInt(val value: Int) fun MyInt.timesTwoBoxed(): MyInt = MyInt(this.value * 2) To make it possible to create an instance of the MyInt class and call the .timesTwoBoxed() function from Java code, add the @JvmExposeBoxed annotation to both the class and the function: @JvmExposeBoxed @JvmInline value class MyInt(val value: Int) @JvmExposeBoxed fun MyInt.timesTwoBoxed(): MyInt = MyInt(this.value * 2) With these annotations, the Kotlin compiler generates a Java-accessible constructor for the MyInt class. It also generates an overload for the extension function that uses the boxed form of the value class. As a result, the following Java code runs successfully: MyInt input = new MyInt(5); MyInt output = ExampleKt.timesTwoBoxed(input); If you don't want to annotate every part of the inline value classes that you want to expose, you can effectively apply the annotation to a whole module. To apply this behavior to a module, compile it with the -Xjvm-expose-boxed option. Compiling with this option has the same effect as if every declaration in the module had the @JvmExposeBoxed annotation. This new annotation does not change how Kotlin compiles or uses value classes internally, and all existing compiled code remains valid. It simply adds new capabilities to improve Java interoperability. The performance of Kotlin code using value classes is not impacted. The @JvmExposeBoxed annotation is useful for library authors who want to expose boxed variants of member functions and receive boxed return types. It eliminates the need to choose between an inline value class (efficient but Kotlin-only) and a data class (Java-compatible but always boxed). For a more detailed explanation of how the @JvmExposedBoxed annotation works and the problems it solves, see this KEEP proposal. Improved support for annotating JVM records Kotlin has supported JVM records since Kotlin 1.5.0. Now, Kotlin 2.2.0 improves how Kotlin handles annotations on record components, particularly in relation to Java's RECORD_COMPONENT target. Firstly, if you want to use a RECORD_COMPONENT as an annotation target, you need to manually add annotations for Kotlin (@Target) and Java. This is because Kotlin's @Target annotation doesn't support RECORD_COMPONENT. For example: @Target(AnnotationTarget.CLASS, AnnotationTarget.PROPERTY) @java.lang.annotation.Target(ElementType.CLASS, ElementType.RECORD_COMPONENT) annotation class exampleClass Maintaining both lists manually can be error-prone, so Kotlin 2.2.0 introduces a compiler warning if the Kotlin and Java targets don't match. For instance, if you omit ElementType.CLASS in the Java target list, the compiler reports: Incompatible annotation targets: Java target 'CLASS' missing, corresponding to Kotlin targets 'CLASS'. Secondly, Kotlin's behavior differs from Java when it comes to propagating annotations in records. In Java, annotations on a record component automatically apply to the backing field, getter, and constructor parameter. Kotlin doesn't do this by default, but you can now replicate the behavior using the @all: use-site target. For example: @JvmRecord data class Person(val name: String, @all:Positive val age: Int) When you use @JvmRecord with @all:, Kotlin now: * Propagates the annotation to the property, backing field, constructor parameter, and getter. * Applies the annotation to the record component, as well, if the annotation supports Java's RECORD_COMPONENT. Kotlin/Native Starting with 2.2.0, Kotlin/Native uses LLVM 19. This release also brings several experimental features designed to track and adjust memory consumption. Experimental Per-object memory allocation Kotlin/Native's memory allocator can now reserve memory on a per-object basis. In some cases, it may help you satisfy strict memory limitations or reduce memory consumption on the application's startup. The new feature is designed to replace the -Xallocator=std compiler option, which enabled the system memory allocator instead of the default one. Now, you can disable buffering (paging of allocations) without switching memory allocators. The feature is currently Experimental. To enable it, set the following option in your gradle.properties file: kotlin.native.binary.pagedAllocator=false Please report any problems to our issue tracker, YouTrack. Experimental Support for Latin-1 encoded strings at runtime Kotlin now supports Latin-1-encoded strings, similarly to the JVM. This should help reduce the application's binary size and adjust memory consumption. By default, strings in Kotlin are stored using UTF-16 encoding, where each character is represented by two bytes. In some cases, this leads to strings taking up twice as much space in the binary compared to the source code, and reading data from a simple ASCII file can take up twice as much memory as storing the file on disk. In turn, Latin-1 (ISO 8859-1) encoding represents each of the first 256 Unicode characters with just one byte. With Latin-1 support enabled, strings are stored in Latin-1 encoding as long as all the characters fall within its range. Otherwise, the default UTF-16 encoding is used. How to enable Latin-1 support The feature is currently Experimental. To enable it, set the following option in your gradle.properties file: kotlin.native.binary.latin1Strings=true Known issues As long as the feature is Experimental, the cinterop extension functions String.pin, String.usePinned, and String.refTo become less efficient. Each call to them may trigger automatic string conversion to UTF-16. The Kotlin team is very grateful to our colleagues at Google and Sonya Valchuk in particular for implementing this feature. For more information on memory consumption in Kotlin, see the documentation. Improved tracking of memory consumption on Apple platforms Starting with Kotlin 2.2.0, memory allocated by Kotlin code is now tagged. This can help you debug memory issues on Apple platforms. When inspecting your application's high memory usage, you can now identify how much memory is reserved by Kotlin code. Kotlin's share is tagged with an identifier and can be tracked through tools like VM Tracker in Xcode Instruments. This feature is enabled by default but is available only in the Kotlin/Native default memory allocator when all the following conditions are met: * Tagging enabled. The memory should be tagged with a valid identifier. Apple recommends numbers between 240 and 255; the default value is 246. If you set up the kotlin.native.binary.mmapTag=0 Gradle property, tagging is disabled. * Allocation with mmap. The allocator should use the mmap system call to map files into memory. If you set up the kotlin.native.binary.disableMmap=true Gradle property, the default allocator uses malloc instead of mmap. * Paging enabled. Paging of allocations (buffering) should be enabled. If you set up the kotlin.native.binary.pagedAllocator=false Gradle property, the memory is reserved on a per-object basis instead. For more information on memory consumption in Kotlin, see the documentation. LLVM update from 16 to 19 In Kotlin 2.2.0, we updated LLVM from version 16 to 19. The new version includes performance improvements, bug fixes, and security updates. This update shouldn't affect your code, but if you encounter any issues, please report them to our issue tracker. Windows 7 target deprecated Starting with Kotlin 2.2.0, the minimal supported Windows version has been raised from Windows 7 to Windows 10. Since Microsoft ended support for Windows 7 in January 2025, we also decided to deprecate this legacy target. For more information, see Kotlin/Native supported targets and hosts. Kotlin/Wasm In this release, the build infrastructure for the Wasm target is separated from the JavaScript target. Additionally, now you can configure the Binaryen tool per project or module. Build infrastructure for Wasm target separated from JavaScript target Before, the wasmJs target shared the same infrastructure as the js target. As a result, both targets were hosted in the same directory (build/js) and used the same NPM tasks and configurations. Now, the wasmJs target has its own infrastructure separate from the js target. This allows Wasm tasks and types to be distinct from JavaScript ones, enabling independent configuration. Additionally, Wasm-related project files and NPM dependencies are now stored in a separate build/wasm directory. New NPM-related tasks have been introduced for Wasm, while existing JavaScript tasks are now dedicated only to JavaScript: Wasm tasks JavaScript tasks kotlinWasmNpmInstall kotlinNpmInstall wasmRootPackageJson rootPackageJson Similarly, new Wasm-specific declarations have been added: Wasm declarations JavaScript declarations WasmNodeJsRootPlugin NodeJsRootPlugin WasmNodeJsPlugin NodeJsPlugin WasmYarnPlugin YarnPlugin WasmNodeJsRootExtension NodeJsRootExtension WasmNodeJsEnvSpec NodeJsEnvSpec WasmYarnRootEnvSpec YarnRootEnvSpec You can now work with the Wasm target independently of the JavaScript target, which simplifies the configuration process. This change is enabled by default and requires no additional setup. Per-project Binaryen configuration The Binaryen tool, used in Kotlin/Wasm to optimize production builds, was previously configured once in the root project. Now, you can configure the Binaryen tool per project or module. This change aligns with Gradle's best practices and ensures better support for features like project isolation, improving build performance and reliability in complex builds. Additionally, you can now configure different versions of Binaryen for different modules, if needed. This feature is enabled by default. However, if you have a custom configuration of Binaryen, you now need to apply it per project, rather than only in the root project. Kotlin/JS This release improves the copy() function in @JsPlainObject interfaces, type aliases in files with the @JsModule annotation, and other Kotlin/JS features. Fix for copy() in @JsPlainObject interfaces Kotlin/JS has an experimental plugin called js-plain-objects, which introduced a copy() function for interfaces annotated with @JsPlainObject. You can use the copy() function to manipulate objects. However, the initial implementation of copy() was not compatible with inheritance, and this caused issues when a @JsPlainObject interface extended other interfaces. To avoid limitations on plain objects, the copy() function has been moved from the object itself to its companion object: @JsPlainObject external interface User { val name: String val age: Int } fun main() { val user = User(name = \"SomeUser\", age = 21) // This syntax is not valid anymore val copy = user.copy(age = 35) // This is the correct syntax val copy = User.copy(user, age = 35) } This change resolves conflicts in the inheritance hierarchy and eliminates ambiguity. It is enabled by default starting from Kotlin 2.2.0. Support for type aliases in files with @JsModule annotation Previously, files annotated with @JsModule to import declarations from JavaScript modules were restricted to external declarations only. This meant that you couldn't declare a typealias in such files. Starting with Kotlin 2.2.0, you can declare type aliases inside files marked with @JsModule: @file:JsModule(\"somepackage\") package somepackage typealias SomeClass = Any This change reduces an aspect of Kotlin/JS interoperability limitations, and more improvements are planned for future releases. Support for type aliases in files with @JsModule is enabled by default. Support for @JsExport in multiplatform expect declarations When working with the expect/actual mechanism in Kotlin Multiplatform projects, it was not possible to use the @JsExport annotation for expect declarations in common code. Starting with this release, you can apply @JsExport directly to expect declarations: // commonMain // Produced error, but now works correctly @JsExport expect class WindowManager { fun close() } @JsExport fun acceptWindowManager(manager: WindowManager) { ... } // jsMain @JsExport actual class WindowManager { fun close() { window.close() } } You must also annotate with @JsExport the corresponding actual implementation in the JavaScript source set, and it has to use only exportable types. This fix allows shared code defined in commonMain to be correctly exported to JavaScript. You can now expose your multiplatform code to JavaScript consumers without having to use manual workarounds. This change is enabled by default. Ability to use @JsExport with the Promise<Unit> type Previously, when you tried to export a function returning the Promise<Unit> type with the @JsExport annotation, the Kotlin compiler produced an error. While return types like Promise<Int> worked correctly, using Promise<Unit> triggered a \"non-exportable type\" warning, even though it correctly mapped to Promise<void> in TypeScript. This restriction has been removed. Now, the following code compiles without error: // Worked correctly before @JsExport fun fooInt(): Promise<Int> = GlobalScope.promise { delay(100) return@promise 42 } // Produced error, but now works correctly @JsExport fun fooUnit(): Promise<Unit> = GlobalScope.promise { delay(100) } This change removes an unnecessary restriction in the Kotlin/JS interop model. This fix is enabled by default. Gradle Kotlin 2.2.0 is fully compatible with Gradle 7.6.3 through 8.14. You can also use Gradle versions up to the latest Gradle release. However, be aware that doing so may result in deprecation warnings, and some new Gradle features might not work. In this release, the Kotlin Gradle plugin comes with several improvements to its diagnostics. It also introduces an experimental integration of binary compatibility validation, making it easier to work on libraries. Experimental Binary compatibility validation included in Kotlin Gradle plugin To make it easier to check for binary compatibility between library versions, we're experimenting with moving the functionality of the binary compatibility validator into the Kotlin Gradle plugin (KGP). You can try it out in toy projects, but we don't recommend using it in production yet. The original binary compatibility validator continues to be maintained during this experimental phase. Kotlin libraries can use one of two binary formats: JVM class files or klib. Since these formats aren't compatible, the KGP works with each of them separately. To enable the binary compatibility validation feature set, add the following to the kotlin{} block in your build.gradle.kts file: // build.gradle.kts kotlin { @OptIn(org.jetbrains.kotlin.gradle.dsl.abi.ExperimentalAbiValidation::class) abiValidation { // Use the set() function to ensure compatibility with older Gradle versions enabled.set(true) } } If your project has multiple modules where you want to check for binary compatibility, configure the feature in each module separately. Each module can have its own custom configuration. Once enabled, run the checkLegacyAbi Gradle task to check for binary compatibility issues. You can run the task in IntelliJ IDEA or from the command line in your project directory: ./gradlew checkLegacyAbi This task generates an application binary interface (ABI) dump from the current code as a UTF-8 text file. The task then compares the new dump with the one from the previous release. If the task finds any differences, it reports them as errors. After reviewing the errors, if you decide the changes are acceptable, you can update the reference ABI dump by running the updateLegacyAbi Gradle task. Filter classes The feature lets you filter classes in the ABI dump. You can include or exclude classes explicitly by name or partial name, or by the annotations (or parts of annotation names) that mark them. For example, this sample excludes all classes in the com.company package: // build.gradle.kts kotlin { @OptIn(org.jetbrains.kotlin.gradle.dsl.abi.ExperimentalAbiValidation::class) abiValidation { filters.excluded.byNames.add(\"com.company.**\") } } Explore the KGP API reference to learn more about configuring the binary compatibility validator. Multiplatform limitations In multiplatform projects, if your host doesn't support cross-compilation for all targets, the KGP tries to infer the ABI changes for unsupported targets by checking the ABI dumps from other ones. This approach helps avoid false validation failures if you later switch to a host that can compile all targets. You can change this default behavior so that the KGP doesn't infer ABI changes for unsupported targets by adding the following to your build.gradle.kts file: // build.gradle.kts kotlin { @OptIn(org.jetbrains.kotlin.gradle.dsl.abi.ExperimentalAbiValidation::class) abiValidation { klib { keepUnsupportedTargets = false } } } However, if you have an unsupported target in your project, running the checkLegacyAbi task fails because the task can't create an ABI dump. This behavior may be desirable if it's more important for the check to fail than to miss an incompatible change due to inferred ABI changes from other targets. Support for rich output in console for Kotlin Gradle plugin In Kotlin 2.2.0, we support color and other rich output in the console during the Gradle build process, making it easier to read and understand the reported diagnostics. Rich output is available in supported terminal emulators for Linux and macOS, and we're working on adding support for Windows. This feature is enabled by default, but if you want to override it, add the following Gradle property to your gradle.properties file: org.gradle.console=plain For more information about this property and its options, see Gradle's documentation on Customizing log format. Integration of Problems API within KGP diagnostics Previously, the Kotlin Gradle Plugin (KGP) was only able to report diagnostics such as warnings and errors as plain text output to the console or logs. Starting with 2.2.0, the KGP introduces an additional reporting mechanism: it now uses Gradle's Problems API, a standardized way to report rich, structured problem information during the build process. The KGP diagnostics are now easier to read and more consistently displayed across different interfaces, such as the Gradle CLI and IntelliJ IDEA. This integration is enabled by default, starting with Gradle 8.6 or later. As the API is still evolving, use the most recent Gradle version to benefit from the latest improvements. KGP compatibility with --warning-mode The Kotlin Gradle Plugin (KGP) diagnostics reported issues using fixed severity levels, meaning Gradle's --warning-mode command-line option had no effect on how the KGP displayed errors. Now, the KGP diagnostics are compatible with the --warning-mode option, providing more flexibility. For example, you can convert all warnings into errors or disable warnings entirely. With this change, the KGP diagnostics adjust the output based on the selected warning mode: * When you set --warning-mode=fail, diagnostics with Severity.Warning are now elevated to Severity.Error. * When you set --warning-mode=none, diagnostics with Severity.Warning are not logged. This behavior is enabled by default starting with 2.2.0. To ignore the --warning-mode option, set the following Gradle property to your gradle.properties file: kotlin.internal.diagnostics.ignoreWarningMode=true Experimental New experimental build tools API You can use Kotlin with various build systems, such as Gradle, Maven, Amper, and others. However, integrating Kotlin into each system to support the full feature set, such as incremental compilation and compatibility with Kotlin compiler plugins, daemons, and Kotlin Multiplatform, requires significant effort. To simplify this process, Kotlin 2.2.0 introduces a new experimental build tools API (BTA). The BTA is a universal API that acts as an abstraction layer between build systems and the Kotlin compiler ecosystem. With this approach, each build system only needs to support a single BTA entry point. Currently, the BTA supports Kotlin/JVM only. The Kotlin team at JetBrains already uses it in the Kotlin Gradle plugin (KGP) and the kotlin-maven-plugin. You can try the BTA through these plugins, but the API itself isn't ready yet for general use in your own build tool integrations. If you're curious about the BTA proposal or want to share your feedback, see this KEEP proposal. To try the BTA in: * The KGP, add the following property to your gradle.properties file: kotlin.compiler.runViaBuildToolsApi=true * Maven, you don't need to do anything. It's enabled by default. The BTA currently has no direct benefits for the Maven plugin, but it lays a solid foundation for the faster delivery of new features, such as support for the Kotlin daemon and the stabilization of incremental compilation. For the KGP, using the BTA already has the following benefits: * Improved \"in process\" compiler execution strategy * More flexibility to configure different compiler versions from Kotlin Improved \"in process\" compiler execution strategy The KGP supports three Kotlin compiler execution strategies. The \"in process\" strategy, which runs the compiler inside the Gradle daemon process, previously didn't support incremental compilation. Now, using the BTA, the \"in-process\" strategy does support incremental compilation. To use it, add the following property to your gradle.properties file: kotlin.compiler.execution.strategy=in-process Flexibility to configure different compiler versions from Kotlin Sometimes you might want to use a newer Kotlin compiler version in your code while keeping the KGP on an older one – for example, to try new language features while still working through build script deprecations. Or you might want to update the version of the KGP but keep an older Kotlin compiler version. The BTA makes this possible. Here's how you can configure it in your build.gradle.kts file: // build.gradle.kts import org.jetbrains.kotlin.buildtools.api.ExperimentalBuildToolsApi import org.jetbrains.kotlin.gradle.ExperimentalKotlinGradlePluginApi plugins { kotlin(\"jvm\") version \"2.2.0\" } group = \"org.jetbrains.example\" version = \"1.0-SNAPSHOT\" repositories { mavenCentral() } kotlin { jvmToolchain(8) @OptIn(ExperimentalBuildToolsApi::class, ExperimentalKotlinGradlePluginApi::class) compilerVersion.set(\"2.1.21\") // Different version than 2.2.0 } The BTA supports configuring the KGP and Kotlin compiler versions with the three previous major versions and one subsequent major version. So in KGP 2.2.0, Kotlin compiler versions 2.1.x, 2.0.x, and 1.9.25 are supported. KGP 2.2.0 is also compatible with future Kotlin compiler versions 2.2.x and 2.3.x. However, keep in mind that using different compiler versions together with compiler plugins may lead to Kotlin compiler exceptions. The Kotlin team plans to address these kinds of problems in future releases. Try out the BTA with these plugins and send us your feedback in the dedicated YouTrack tickets for the KGP and the Maven plugin. Standard library In Kotlin 2.2.0, the Base64 API and HexFormat API are now Stable. Stable Base64 encoding and decoding Kotlin 1.8.20 introduced Experimental support for Base64 encoding and decoding. In Kotlin 2.2.0, the Base64 API is now Stable and includes four encoding schemes, with the new Base64.Pem added in this release: * Base64.Default uses the standard Base64 encoding scheme. The Base64.Default is the companion object of the Base64 class. As a result, you can call its functions with Base64.encode() and Base64.decode() instead of Base64.Default.encode() and Base64.Default.decode(). * Base64.UrlSafe uses the \"URL and Filename safe\" encoding scheme. * Base64.Mime uses the MIME encoding scheme, inserting a line separator every 76 characters during encoding and skipping illegal characters during decoding. * Base64.Pem encodes data like Base64.Mime but limits the line length to 64 characters. You can use the Base64 API to encode binary data into a Base64 string and decode it back into bytes. Here's an example: val foBytes = \"fo\".map { it.code.toByte() }.toByteArray() Base64.Default.encode(foBytes) // \"Zm8=\" // Alternatively: // Base64.encode(foBytes) val foobarBytes = \"foobar\".map { it.code.toByte() }.toByteArray() Base64.UrlSafe.encode(foobarBytes) // \"Zm9vYmFy\" Base64.Default.decode(\"Zm8=\") // foBytes // Alternatively: // Base64.decode(\"Zm8=\") Base64.UrlSafe.decode(\"Zm9vYmFy\") // foobarBytes On the JVM, use the .encodingWith() and .decodingWith() extension functions to encode and decode Base64 with input and output streams: import kotlin.io.encoding.* import java.io.ByteArrayOutputStream fun main() { val output = ByteArrayOutputStream() val base64Output = output.encodingWith(Base64.Default) base64Output.use { stream -> stream.write(\"Hello World!!\".encodeToByteArray()) } println(output.toString()) // SGVsbG8gV29ybGQhIQ== } Stable Hexadecimal parsing and formatting with the HexFormat API The HexFormat API introduced in Kotlin 1.9.0 is now Stable. You can use it to convert between numerical values and hexadecimal strings. For example: println(93.toHexString()) ​ Open in Playground → Target: JVM Running on v.2.3.0 For more information, see New HexFormat class to format and parse hexadecimals. Compose compiler In this release, the Compose compiler introduces support for composable function references and changes defaults for several feature flags. Support for @Composable function references The Compose compiler supports the declaration and usage of composable function references starting from the Kotlin 2.2.0 release: val content: @Composable (String) -> Unit = ::Text @Composable fun App() { content(\"My App\") } Composable function references behave slightly differently from composable lambda objects at runtime. In particular, composable lambdas allow for finer control over skipping by extending the ComposableLambda class. Function references are expected to implement the KCallable interface, so the same optimization cannot be applied to them. PausableComposition feature flag enabled by default The PausableComposition feature flag is enabled by default starting from Kotlin 2.2.0. This flag adjusts the Compose compiler output for restartable functions, allowing runtime to force skipping behavior and therefore effectively pause composition by skipping each function. This allows heavy compositions to be split between frames, which will be used by prefetching in a future release. To disable this feature flag, add the following to your Gradle configuration: // build.gradle.kts composeCompiler { featureFlag = setOf(ComposeFeatureFlag.PausableComposition.disabled()) } OptimizeNonSkippingGroups feature flag enabled by default The OptimizeNonSkippingGroups feature flag is enabled by default starting from Kotlin 2.2.0. This optimization improves runtime performance by removing group calls generated for non-skipping composable functions. It should not result in any observable behavior changes at runtime. If you encounter any issues, you can validate that this change causes the issue by disabling the feature flag. Please report any issues to the Jetpack Compose issue tracker. To disable the OptimizeNonSkippingGroups flag, add the following to your Gradle configuration: composeCompiler { featureFlag = setOf(ComposeFeatureFlag.OptimizeNonSkippingGroups.disabled()) } Deprecated feature flags The StrongSkipping and IntrinsicRemember feature flags are now deprecated and will be removed in a future release. If you encounter any issues that make you disable these feature flags, please report them to the Jetpack Compose issue tracker. Breaking changes and deprecations This section highlights important breaking changes and deprecations worth noting. See our Compatibility guide for a complete overview of all breaking changes and deprecations in this release. * Starting with Kotlin 2.2.0, the compiler no longer supports -language-version=1.6 or -language-version=1.7. Language feature sets older than 1.8 aren't supported but the language itself remains fully backward compatible with Kotlin 1.0. * Support for the Ant build system is deprecated. Kotlin support for Ant hasn't been in active development for a long time, and there are no plans to maintain it further due to its relatively small user base. We plan to remove Ant support in 2.3.0. * Kotlin 2.2.0 raises the deprecation level of the kotlinOptions{} block in Gradle to error. Use the compilerOptions{} block instead. For guidance on updating your build scripts, see Migrate from kotlinOptions{} to compilerOptions{}. * Kotlin scripting remains an important part of Kotlin's ecosystem, but we're focusing on specific use cases such as custom scripting, as well as gradle.kts and main.kts scripts, to provide a better experience. To learn more, see our updated blog post. As a result, Kotlin 2.2.0 deprecates support for: * REPL: To continue to use REPL via kotlinc, opt in with the -Xrepl compiler option. * JSR-223: Since this JSR is in the Withdrawn state, the JSR-223 implementation continues to work with language version 1.9 but won't be migrated to use the K2 compiler in the future. * The KotlinScriptMojo Maven plugin: We didn't see enough traction with this plugin. You will see compiler warnings if you continue to use it. * * In Kotlin 2.2.0, the setSource() function in KotlinCompileTool now replaces configured sources instead of adding to them. If you want to add sources without replacing existing ones, use the source() function. * The type of annotationProcessorOptionProviders in BaseKapt has been changed from MutableList<Any> to MutableList<CommandLineArgumentProvider>. If your code currently adds a list as a single element, use the addAll() function instead of the add() function. * Following the deprecation of the dead code elimination (DCE) tool used in the legacy Kotlin/JS backend, the remaining DSLs related to DCE are now removed from the Kotlin Gradle plugin: * The org.jetbrains.kotlin.gradle.dsl.KotlinJsDce interface * The org.jetbrains.kotlin.gradle.targets.js.dsl.KotlinJsBrowserDsl.dceTask(body: Action<KotlinJsDce>) function * The org.jetbrains.kotlin.gradle.dsl.KotlinJsDceCompilerToolOptions interface * The org.jetbrains.kotlin.gradle.dsl.KotlinJsDceOptions interface * The current JS IR compiler supports DCE out of the box, and the @JsExport annotation allows specifying which Kotlin functions and classes to retain during DCE. * The deprecated kotlin-android-extensions plugin is removed in Kotlin 2.2.0. Use the kotlin-parcelize plugin for the Parcelable implementation generator and the Android Jetpack's view bindings for synthetic views instead. * Experimental kotlinArtifacts API is deprecated in Kotlin 2.2.0. Use the current DSL available in the Kotlin Gradle plugin to build final native binaries. If it's not sufficient for migration, leave a comment in this YouTrack issue. * KotlinCompilation.source, deprecated in Kotlin 1.9.0, is now removed from the Kotlin Gradle plugin. * The parameters for experimental commonization modes are deprecated in Kotlin 2.2.0. Clear the commonization cache to delete invalid compilation artifacts. * The deprecated konanVersion property is now removed from the CInteropProcess task. Use CInteropProcess.kotlinNativeVersion instead. * Usage of the deprecated destinationDir property will now lead to an error. Use CInteropProcess.destinationDirectory.set() instead. Documentation updates This release brings notable documentation changes, including the migration of Kotlin Multiplatform documentation to the KMP portal. Additionally, we created new pages and tutorials, and revamped existing ones. New and revamped tutorials * Kotlin intermediate tour – Take your understanding of Kotlin to the next level. Learn when to use extension functions, interfaces, classes, and more. * Build a Kotlin app that uses Spring AI – Learn how to create a Kotlin app that answers questions using OpenAI and a vector database. * Create a Spring Boot project with Kotlin – Learn how to create a Spring Boot project with Gradle using IntelliJ IDEA's New Project wizard. * Mapping Kotlin and C tutorial series – Learn how different types and constructs are mapped between Kotlin and C. * Create an app using C interop and libcurl – Create a simple HTTP client that can run natively using the libcurl C library. * Create your Kotlin Multiplatform library – Learn how to create and publish a multiplatform library using IntelliJ IDEA. * Build a full-stack application with Ktor and Kotlin Multiplatform – This tutorial now uses IntelliJ IDEA instead of Fleet, along with Material 3 and the latest versions of Ktor and Kotlin. * Manage local resource environment in your Compose Multiplatform app – Learn how to manage the application's resource environment, like in-app theme and language. New and revamped pages * Kotlin for AI overview – Discover Kotlin's capabilities for building AI-powered applications. * Dokka migration guide – Learn how to migrate to v2 of the Dokka Gradle plugin. * Kotlin Metadata JVM library – Explore guidance on reading, modifying, and generating metadata for Kotlin classes compiled for the JVM. * CocoaPods integration – Learn how to set up the environment, add Pod dependencies, or use a Kotlin project as a CocoaPod dependency through tutorials and sample projects. * New pages for Compose Multiplatform to support the iOS stable release: * Navigation and Deep linking in particular. * Implementing layouts in Compose. * Localizing strings and other i18n pages like support for RTL languages. * Compose Hot Reload – Learn how to use Compose Hot Reload with your desktop targets and how to add it to an existing project. * Exposed migrations – Learn about the tools Exposed provides for managing database schema changes. How to update to Kotlin 2.2.0 The Kotlin plugin is distributed as a bundled plugin in IntelliJ IDEA and Android Studio. To update to the new Kotlin version, change the Kotlin version to 2.2.0 in your build scripts.",
        "crawl_status": "success"
      },
      {
        "library_name": "Kotlin",
        "url": "https://kotlinlang.org/docs/whatsnew19.html",
        "version": "Unknown version",
        "title": "What's new in Kotlin 1.9.0 | Kotlin Documentation",
        "release_date": "Unknown release date",
        "content": "What's new in Kotlin 1.9.0 Edit page01 October 2025 Release date: July 6, 2023 The Kotlin 1.9.0 release is out and the K2 compiler for the JVM is now in Beta. Additionally, here are some of the main highlights: * New Kotlin K2 compiler updates * Stable replacement of the enum class values function * Stable ..< operator for open-ended ranges * New common function to get regex capture group by name * New path utility to create parent directories * Preview of the Gradle configuration cache in Kotlin Multiplatform * Changes to Android target support in Kotlin Multiplatform * Preview of custom memory allocator in Kotlin/Native * Library linkage in Kotlin/Native * Size-related optimizations in Kotlin/Wasm You can also find a short overview of the updates in this video: IDE support The Kotlin plugins that support 1.9.0 are available for: IDE Supported versions IntelliJ IDEA 2022.3.x, 2023.1.x Android Studio Giraffe (223), Hedgehog (231)* *The Kotlin 1.9.0 plugin will be included with Android Studio Giraffe (223) and Hedgehog (231) in their upcoming releases. The Kotlin 1.9.0 plugin will be included with IntelliJ IDEA 2023.2 in the upcoming releases. To download Kotlin artifacts and dependencies, configure your Gradle settings to use the Maven Central Repository. New Kotlin K2 compiler updates The Kotlin team at JetBrains continues to stabilize the K2 compiler, and the 1.9.0 release introduces further advancements. The K2 compiler for the JVM is now in Beta. There's now also basic support for Kotlin/Native and multiplatform projects. Compatibility of the kapt compiler plugin with the K2 compiler You can use the kapt plugin in your project along with the K2 compiler, but with some restrictions. Despite setting languageVersion to 2.0, the kapt compiler plugin still utilizes the old compiler. If you execute the kapt compiler plugin within a project where languageVersion is set to 2.0, kapt will automatically switch to 1.9 and disable specific version compatibility checks. This behavior is equivalent to including the following command arguments: * -Xskip-metadata-version-check * -Xskip-prerelease-check * -Xallow-unstable-dependencies These checks are exclusively disabled for kapt tasks. All other compilation tasks will continue to utilize the new K2 compiler. If you encounter any issues when using kapt with the K2 compiler, please report them to our issue tracker. Try the K2 compiler in your project Starting with 1.9.0 and until the release of Kotlin 2.0, you can easily test the K2 compiler by adding the kotlin.experimental.tryK2=true Gradle property to your gradle.properties file. You can also run the following command: ./gradlew assemble -Pkotlin.experimental.tryK2=true This Gradle property automatically sets the language version to 2.0 and updates the build report with the number of Kotlin tasks compiled using the K2 compiler compared to the current compiler: ##### 'kotlin.experimental.tryK2' results (Kotlin/Native not checked) ##### :lib:compileKotlin: 2.0 language version :app:compileKotlin: 2.0 language version ##### 100% (2/2) tasks have been compiled with Kotlin 2.0 ##### Gradle build reports Gradle build reports now show whether the current or the K2 compiler was used to compile the code. In Kotlin 1.9.0, you can see this information in your Gradle build scans: You can also find the Kotlin version used in the project right in the build report: Task info: Kotlin language version: 1.9 If you use Gradle 8.0, you might come across some problems with build reports, especially when Gradle configuration caching is enabled. This is a known issue, fixed in Gradle 8.1 and later. Current K2 compiler limitations Enabling K2 in your Gradle project comes with certain limitations that can affect projects using Gradle versions below 8.3 in the following cases: * Compilation of source code from buildSrc. * Compilation of Gradle plugins in included builds. * Compilation of other Gradle plugins if they are used in projects with Gradle versions below 8.3. * Building Gradle plugin dependencies. If you encounter any of the problems mentioned above, you can take the following steps to address them: * Set the language version for buildSrc, any Gradle plugins, and their dependencies: kotlin { compilerOptions { languageVersion.set(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_1_9) apiVersion.set(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_1_9) } } * Update the Gradle version in your project to 8.3 when it becomes available. Leave your feedback on the new K2 compiler We'd appreciate any feedback you may have! * Provide your feedback directly to K2 developers Kotlin's Slack – get an invite and join the #k2-early-adopters channel. * Report any problems you've faced with the new K2 compiler on our issue tracker. * Enable the Send usage statistics option to allow JetBrains to collect anonymous data about K2 usage. Language In Kotlin 1.9.0, we're stabilizing some new language features that were introduced earlier: * Replacement of the enum class values function * Data object symmetry with data classes * Support for secondary constructors with bodies in inline value classes Stable replacement of the enum class values function In 1.8.20, the entries property for enum classes was introduced as an Experimental feature. The entries property is a modern and performant replacement for the synthetic values() function. In 1.9.0, the entries property is Stable. The values() function is still supported, but we recommend that you use the entries property instead. enum class Color(val colorName: String, val rgb: String) { RED(\"Red\", \"#FF0000\"), ORANGE(\"Orange\", \"#FF7F00\"), YELLOW(\"Yellow\", \"#FFFF00\") } fun findByRgb(rgb: String): Color? = Color.entries.find { it.rgb == rgb } For more information about the entries property for enum classes, see What's new in Kotlin 1.8.20. Stable data objects for symmetry with data classes Data object declarations, which were introduced in Kotlin 1.8.20, are now Stable. This includes the functions added for symmetry with data classes: toString(), equals(), and hashCode(). This feature is particularly useful with sealed hierarchies (like a sealed class or sealed interface hierarchy), because data object declarations can be used conveniently alongside data class declarations. In this example, declaring EndOfFile as a data object instead of a plain object means that it automatically has a toString() function without the need to override it manually. This maintains symmetry with the accompanying data class definitions. sealed interface ReadResult data class Number(val number: Int) : ReadResult data class Text(val text: String) : ReadResult data object EndOfFile : ReadResult fun main() { println(Number(7)) // Number(number=7) println(EndOfFile) // EndOfFile } For more information, see What's new in Kotlin 1.8.20. Support for secondary constructors with bodies in inline value classes Starting with Kotlin 1.9.0, the use of secondary constructors with bodies in inline value classes is available by default: @JvmInline value class Person(private val fullName: String) { // Allowed since Kotlin 1.4.30: init { check(fullName.isNotBlank()) { \"Full name shouldn't be empty\" } } // Allowed by default since Kotlin 1.9.0: constructor(name: String, lastName: String) : this(\"$name $lastName\") { check(lastName.isNotBlank()) { \"Last name shouldn't be empty\" } } } Previously, Kotlin allowed only public primary constructors in inline classes. As a result, it was impossible to encapsulate underlying values or create an inline class that would represent some constrained values. As Kotlin developed, these issues were fixed. Kotlin 1.4.30 lifted restrictions on init blocks and then Kotlin 1.8.20 came with a preview of secondary constructors with bodies. They are now available by default. Learn more about the development of Kotlin inline classes in this KEEP. Kotlin/JVM Starting with version 1.9.0, the compiler can generate classes with a bytecode version corresponding to JVM 20. In addition, the deprecation of the JvmDefault annotation and legacy -Xjvm-default modes continues. Deprecation of JvmDefault annotation and legacy -Xjvm-default modes Starting from Kotlin 1.5, the usage of the JvmDefault annotation has been deprecated in favor of the newer -Xjvm-default modes: all and all-compatibility. With the introduction of JvmDefaultWithoutCompatibility in Kotlin 1.4 and JvmDefaultWithCompatibility in Kotlin 1.6, these modes offer comprehensive control over the generation of DefaultImpls classes, ensuring seamless compatibility with older Kotlin code. Consequently in Kotlin 1.9.0, the JvmDefault annotation no longer holds any significance and has been marked as deprecated, resulting in an error. It will eventually be removed from Kotlin. Kotlin/Native Among other improvements, this release brings further advancements to the Kotlin/Native memory manager that should enhance its robustness and performance: * Preview of custom memory allocator * Objective-C or Swift object deallocation hook on the main thread * No object initialization when accessing constant values in Kotlin/Native * Ability to configure standalone mode for iOS simulator tests * Library linkage in Kotlin/Native Preview of custom memory allocator Kotlin 1.9.0 introduces the preview of a custom memory allocator. Its allocation system improves the runtime performance of the Kotlin/Native memory manager. The current object allocation system in Kotlin/Native uses a general-purpose allocator that doesn't have the functionality for efficient garbage collection. To compensate, it maintains thread-local linked lists of all allocated objects before the garbage collector (GC) merges them into a single list, which can be iterated during sweeping. This approach comes with several performance downsides: * The sweeping order lacks memory locality and often results in scattered memory access patterns, leading to potential performance issues. * Linked lists require additional memory for each object, increasing memory usage, particularly when dealing with many small objects. * The single list of allocated objects makes it challenging to parallelize sweeping, which can cause memory usage problems when mutator threads allocate objects faster than the GC thread can collect them. To address these issues, Kotlin 1.9.0 introduces a preview of the custom allocator. It divides system memory into pages, allowing independent sweeping in consecutive order. Each allocation becomes a memory block within a page, and the page keeps track of block sizes. Different page types are optimized for various allocation sizes. The consecutive arrangement of memory blocks ensures efficient iteration through all allocated blocks. When a thread allocates memory, it searches for a suitable page based on the allocation size. Threads maintain a set of pages for different size categories. Typically, the current page for a given size can accommodate the allocation. If not, the thread requests a different page from the shared allocation space. This page may already be available, require sweeping, or should be created first. The new allocator allows having multiple independent allocation spaces simultaneously, which will allow the Kotlin team to experiment with different page layouts to improve performance even further. For more information on the design of the new allocator, see this README. How to enable Add the -Xallocator=custom compiler option: kotlin { macosX64(\"native\") { binaries.executable() compilations.configureEach { compilerOptions.configure { freeCompilerArgs.add(\"-Xallocator=custom\") } } } } Leave feedback We would appreciate your feedback in YouTrack to improve the custom allocator. Objective-C or Swift object deallocation hook on the main thread Starting with Kotlin 1.9.0, the Objective-C or Swift object deallocation hook is called on the main thread if the object is passed to Kotlin there. The way the Kotlin/Native memory manager previously handled references to Objective-C objects could lead to memory leaks. We believe the new behavior should improve the robustness of the memory manager. Consider an Objective-C object that is referenced in Kotlin code, for example, when passed as an argument, returned by a function, or retrieved from a collection. In this case, Kotlin creates its own object that holds the reference to the Objective-C object. When the Kotlin object gets deallocated, the Kotlin/Native runtime calls the objc_release function that releases that Objective-C reference. Previously, the Kotlin/Native memory manager ran objc_release on a special GC thread. If it's the last object reference, the object gets deallocated. Issues could come up when Objective-C objects have custom deallocation hooks like the dealloc method in Objective-C or the deinit block in Swift, and these hooks expect to be called on a specific thread. Since hooks for objects on the main thread usually expect to be called there, Kotlin/Native runtime now calls objc_release on the main thread as well. It should cover the cases when the Objective-C object was passed to Kotlin on the main thread, creating a Kotlin peer object there. This only works if the main dispatch queue is processed, which is the case for regular UI applications. When it's not the main queue or the object was passed to Kotlin on a thread other than main, the objc_release is called on a special GC thread as before. How to opt out In case you face issues, you can disable this behavior in your gradle.properties file with the following option: kotlin.native.binary.objcDisposeOnMain=false Don't hesitate to report such cases to our issue tracker. No object initialization when accessing constant values in Kotlin/Native Starting with Kotlin 1.9.0, the Kotlin/Native backend doesn't initialize objects when accessing const val fields: object MyObject { init { println(\"side effect!\") } const val y = 1 } fun main() { println(MyObject.y) // No initialization at first val x = MyObject // Initialization occurs println(x.y) } The behavior is now unified with Kotlin/JVM, where the implementation is consistent with Java and objects are never initialized in this case. You can also expect some performance improvements in your Kotlin/Native projects thanks to this change. Ability to configure standalone mode for iOS simulator tests in Kotlin/Native By default, when running iOS simulator tests for Kotlin/Native, the --standalone flag is used to avoid manual simulator booting and shutdown. In 1.9.0, you can now configure whether this flag is used in a Gradle task via the standalone property. By default, the --standalone flag is used so standalone mode is enabled. Here is an example of how to disable standalone mode in your build.gradle.kts file: tasks.withType<org.jetbrains.kotlin.gradle.targets.native.tasks.KotlinNativeSimulatorTest>().configureEach { standalone.set(false) } If you disable standalone mode, you must boot the simulator manually. To boot your simulator from CLI, you can use the following command: /usr/bin/xcrun simctl boot <DeviceId> Library linkage in Kotlin/Native Starting with Kotlin 1.9.0, the Kotlin/Native compiler treats linkage issues in Kotlin libraries the same way as Kotlin/JVM. You might face such issues if the author of one third-party Kotlin library makes an incompatible change in experimental APIs that another third-party Kotlin library consumes. Now builds don't fail during compilation in case of linkage issues between third-party Kotlin libraries. Instead, you'll only encounter these errors in run time, exactly as on the JVM. The Kotlin/Native compiler reports warnings every time it detects issues with library linkage. You can find such warnings in your compilation logs, for example: No function found for symbol 'org.samples/MyRemovedClass.doSomething|3657632771909858561[0]' Can not get instance of singleton 'MyEnumClass.REMOVED_ENTRY': No enum entry found for symbol 'org.samples/MyEnumClass.REMOVED_ENTRY|null[0]' Function 'getMyRemovedClass' can not be called: Function uses unlinked class symbol 'org.samples/MyRemovedClass|null[0]' You can further configure or even disable this behavior in your projects: * If you don't want to see these warnings in your compilation logs, suppress them with the -Xpartial-linkage-loglevel=INFO compiler option. * It's also possible to raise the severity of reported warnings to compilation errors with -Xpartial-linkage-loglevel=ERROR. In this case, the compilation fails and you'll see all the errors in the compilation log. Use this option to examine the linkage issues more closely. * If you face unexpected problems with this feature, you can always opt out with the -Xpartial-linkage=disable compiler option. Don't hesitate to report such cases to our issue tracker. // An example of passing compiler options via Gradle build file. kotlin { macosX64(\"native\") { binaries.executable() compilations.configureEach { compilerOptions.configure { // To suppress linkage warnings: freeCompilerArgs.add(\"-Xpartial-linkage-loglevel=INFO\") // To raise linkage warnings to errors: freeCompilerArgs.add(\"-Xpartial-linkage-loglevel=ERROR\") // To disable the feature completely: freeCompilerArgs.add(\"-Xpartial-linkage=disable\") } } } } Compiler option for C interop implicit integer conversions We have introduced a compiler option for C interop that allows you to use implicit integer conversions. After careful consideration, we've introduced this compiler option to prevent unintentional use as this feature still has room for improvement and our aim is to have an API of the highest quality. In this code sample an implicit integer conversion allows options = 0 even though options has unsigned type UInt and 0 is signed. val today = NSDate() val tomorrow = NSCalendar.currentCalendar.dateByAddingUnit( unit = NSCalendarUnitDay, value = 1, toDate = today, options = 0 ) To use implicit conversions with native interop libraries, use the -XXLanguage:+ImplicitSignedToUnsignedIntegerConversion compiler option. You can configure this in your Gradle build.gradle.kts file: tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinNativeCompile>().configureEach { compilerOptions.freeCompilerArgs.addAll( \"-XXLanguage:+ImplicitSignedToUnsignedIntegerConversion\" ) } Kotlin Multiplatform Kotlin Multiplatform has received some notable updates in 1.9.0 designed to improve your developer experience: * Changes to Android target support * New Android source set layout enabled by default * Preview of the Gradle configuration cache in multiplatform projects Changes to Android target support We continue our efforts to stabilize Kotlin Multiplatform. An essential step is to provide first-class support for the Android target. We're excited to announce that in the future, the Android team from Google will provide its own Gradle plugin to support Android in Kotlin Multiplatform. To open the way for this new solution from Google, we're renaming the android block in the current Kotlin DSL in 1.9.0. Please change all the occurrences of the android block to androidTarget in your build scripts. This is a temporary change that is necessary to free the android name for the upcoming DSL from Google. The Google plugin will be the preferred way of working with Android in multiplatform projects. When it's ready, we'll provide the necessary migration instructions so that you'll be able to use the short android name as before. New Android source set layout enabled by default Starting with Kotlin 1.9.0, the new Android source set layout is the default. It replaced the previous naming schema for directories, which was confusing in multiple ways. The new layout has a number of advantages: * Simplified type semantics – The new Android source layout provides clear and consistent naming conventions that help to distinguish between different types of source sets. * Improved source directory layout – With the new layout, the SourceDirectories arrangement becomes more coherent, making it easier to organize code and locate source files. * Clear naming schema for Gradle configurations – The schema is now more consistent and predictable in both KotlinSourceSets and AndroidSourceSets. The new layout requires the Android Gradle plugin version 7.0 or later and is supported in Android Studio 2022.3 and later. See our migration guide to make the necessary changes in your build.gradle(.kts) file. Preview of the Gradle configuration cache Kotlin 1.9.0 comes with support for the Gradle configuration cache in multiplatform libraries. If you're a library author, you can already benefit from the improved build performance. The Gradle configuration cache speeds up the build process by reusing the results of the configuration phase for subsequent builds. The feature has become Stable since Gradle 8.1. To enable it, follow the instructions in the Gradle documentation. The Kotlin Multiplatform plugin still doesn't support the Gradle configuration cache with Xcode integration tasks or the Kotlin CocoaPods Gradle plugin. We expect to add this feature in future Kotlin releases. Kotlin/Wasm The Kotlin team continues to experiment with the new Kotlin/Wasm target. This release introduces several performance and size-related optimizations, along with updates in JavaScript interop. Size-related optimizations Kotlin 1.9.0 introduces significant size improvements for WebAssembly (Wasm) projects. Comparing two \"Hello World\" projects, the code footprint for Wasm in Kotlin 1.9.0 is now over 10 times smaller than in Kotlin 1.8.20. These size optimizations result in more efficient resource utilization and improved performance when targeting Wasm platforms with Kotlin code. Updates in JavaScript interop This Kotlin update introduces changes to the interoperability between Kotlin and JavaScript for Kotlin/Wasm. As Kotlin/Wasm is an Experimental feature, certain limitations apply to its interoperability. Restriction of Dynamic types Starting with version 1.9.0, Kotlin no longer supports the use of Dynamic types in Kotlin/Wasm. This is now deprecated in favor of the new universal JsAny type, which facilitates JavaScript interoperability. For more details, see the Kotlin/Wasm interoperability with JavaScript documentation. Restriction of non-external types Kotlin/Wasm supports conversions for specific Kotlin static types when passing values to and from JavaScript. These supported types include: * Primitives, such as signed numbers, Boolean, and Char. * String. * Function types. Other types were passed without conversion as opaque references, leading to inconsistencies between JavaScript and Kotlin subtyping. To address this, Kotlin restricts JavaScript interop to a well-supported set of types. Starting from Kotlin 1.9.0, only external, primitive, string, and function types are supported in Kotlin/Wasm JavaScript interop. Furthermore, a separate explicit type called JsReference has been introduced to represent handles to Kotlin/Wasm objects that can be used in JavaScript interop. For more details, refer to the Kotlin/Wasm interoperability with JavaScript documentation. Kotlin/Wasm in Kotlin Playground Kotlin Playground supports the Kotlin/Wasm target. You can write, run, and share your Kotlin code that targets the Kotlin/Wasm. Check it out! Using Kotlin/Wasm requires enabling experimental features in your browser. Learn more about how to enable these features. import kotlin.time.* import kotlin.time.measureTime ​ fun main() { println(\"Hello from Kotlin/Wasm!\") computeAck(3, 10) } ​ tailrec fun ack(m: Int, n: Int): Int = when { m == 0 -> n + 1 n == 0 -> ack(m - 1, 1) else -> ack(m - 1, ack(m, n - 1)) } ​ fun computeAck(m: Int, n: Int) { var res = 0 val t = measureTime { res = ack(m, n) } println() println(\"ack($m, $n) = ${res}\") println(\"duration: ${t.inWholeNanoseconds / 1e6} ms\") } Open in Playground → Target: JVM Running on v.2.3.0 Kotlin/JS This release introduces updates for Kotlin/JS, including the removal of the old Kotlin/JS compiler, Kotlin/JS Gradle plugin deprecation and Experimental support for ES2015: * Removal of the old Kotlin/JS compiler * Deprecation of the Kotlin/JS Gradle plugin * Deprecation of external enum * Experimental support for ES2015 classes and modules * Changed default destination of JS production distribution * Extract org.w3c declarations from stdlib-js Starting from version 1.9.0, partial library linkage is also enabled for Kotlin/JS. Removal of the old Kotlin/JS compiler In Kotlin 1.8.0, we announced that the IR-based backend became Stable. Since then, not specifying the compiler has become an error, and using the old compiler leads to warnings. In Kotlin 1.9.0, using the old backend results in an error. Please migrate to the IR compiler. Deprecation of the Kotlin/JS Gradle plugin Starting with Kotlin 1.9.0, the kotlin-js Gradle plugin is deprecated. We encourage you to use the kotlin-multiplatform Gradle plugin with the js() target instead. The functionality of the Kotlin/JS Gradle plugin essentially duplicated the kotlin-multiplatform plugin and shared the same implementation under the hood. This overlap created confusion and increased maintenance load on the Kotlin team. Refer to our Compatibility guide for Kotlin Multiplatform for migration instructions. If you find any issues that aren't covered in the guide, please report them to our issue tracker. Deprecation of external enum In Kotlin 1.9.0, the use of external enums will be deprecated due to issues with static enum members like entries, that can't exist outside Kotlin. We recommend using an external sealed class with object subclasses instead: // Before external enum class ExternalEnum { A, B } // After external sealed class ExternalEnum { object A: ExternalEnum object B: ExternalEnum } By switching to an external sealed class with object subclasses, you can achieve similar functionality to external enums while avoiding the problems associated with default methods. Starting from Kotlin 1.9.0, the use of external enums will be marked as deprecated. We encourage you to update your code to utilize the suggested external sealed class implementation for compatibility and future maintenance. Experimental support for ES2015 classes and modules This release introduces Experimental support for ES2015 modules and generation of ES2015 classes: * Modules offer a way to simplify your codebase and improve maintainability. * Classes allow you to incorporate object-oriented programming (OOP) principles, resulting in cleaner and more intuitive code. To enable these features, update your build.gradle.kts file accordingly: // build.gradle.kts kotlin { js(IR) { useEsModules() // Enables ES2015 modules browser() } } // Enables ES2015 classes generation tasks.withType<KotlinJsCompile>().configureEach { kotlinOptions { useEsClasses = true } } Learn more about ES2015 (ECMAScript 2015, ES6) in the official documentation. Changed default destination of JS production distribution Prior to Kotlin 1.9.0, the distribution target directory was build/distributions. However, this is a common directory for Gradle archives. To resolve this issue, we've changed the default distribution target directory in Kotlin 1.9.0 to: build/dist/<targetName>/<binaryName>. For example, productionExecutable was in build/distributions. In Kotlin 1.9.0, it's in build/dist/js/productionExecutable. If you have a pipeline in place that uses the results of these builds, make sure to update the directory. Extract org.w3c declarations from stdlib-js Since Kotlin 1.9.0, the stdlib-js no longer includes org.w3c declarations. Instead, these declarations have been moved to a separate Gradle dependency. When you add the Kotlin Multiplatform Gradle plugin to your build.gradle.kts file, these declarations will be automatically included in your project, similar to the standard library. There is no need for any manual action or migration. The necessary adjustments will be handled automatically. Gradle Kotlin 1.9.0 comes with new Gradle compiler options and a lot more: * Removed classpath property * New Gradle compiler options * Project-level compiler options for Kotlin/JVM * Compiler option for Kotlin/Native module name * Separate compiler plugins for official Kotlin libraries * Incremented minimum supported version * kapt doesn't cause eager task creation * Programmatic configuration of the JVM target validation mode Removed classpath property In Kotlin 1.7.0, we announced the start of a deprecation cycle for the KotlinCompile task's property: classpath. The deprecation level was raised to ERROR in Kotlin 1.8.0. In this release, we've finally removed the classpath property. All compile tasks should now use the libraries input for a list of libraries required for compilation. New compiler options The Kotlin Gradle plugin now provides new properties for opt-ins and the compiler's progressive mode. * To opt in to new APIs, you can now use the optIn property and pass a list of strings like: optIn.set(listOf(a, b, c)). * To enable progressive mode, use progressiveMode.set(true). Project-level compiler options for Kotlin/JVM Starting with Kotlin 1.9.0, a new compilerOptions block is available inside the kotlin configuration block: kotlin { compilerOptions { jvmTarget.set(JVM.Target_11) } } It makes configuring compiler options much easier. However, it is important to note some important details: * This configuration only works on the project level. * For the Android plugin, this block configures the same object as: android { kotlinOptions {} } * The android.kotlinOptions and kotlin.compilerOptions configuration blocks override each other. The last (lowest) block in the build file always takes effect. * If moduleName is configured on the project level, its value could be changed when passed to the compiler. It's not the case for the main compilation, but for other types, for example, test sources, the Kotlin Gradle plugin will add the _test suffix. * The configuration inside the tasks.withType<KotlinJvmCompile>().configureEach {} (or tasks.named<KotlinJvmCompile>(\"compileKotlin\") { }) overrides both kotlin.compilerOptions and android.kotlinOptions. Compiler option for Kotlin/Native module name The Kotlin/Native module-name compiler option is now easily available in the Kotlin Gradle plugin. This option specifies a name for the compilation module and can also be used for adding a name prefix for declarations exported to Objective-C. You can now set the module name directly in the compilerOptions block of your Gradle build files: Kotlin Groovy tasks.named<org.jetbrains.kotlin.gradle.tasks.KotlinNativeCompile>(\"compileKotlinLinuxX64\") { compilerOptions { moduleName.set(\"my-module-name\") } } Separate compiler plugins for official Kotlin libraries Kotlin 1.9.0 introduces separate compiler plugins for its official libraries. Previously, compiler plugins were embedded into their corresponding Gradle plugins. This could cause compatibility issues in case the compiler plugin was compiled against a Kotlin version higher than the Gradle build's Kotlin runtime version. Now compiler plugins are added as separate dependencies, so you'll no longer face compatibility issues with older Gradle versions. Another major advantage of the new approach is that new compiler plugins can be used with other build systems like Bazel. Here's the list of new compiler plugins we're now publishing to Maven Central: * kotlin-atomicfu-compiler-plugin * kotlin-allopen-compiler-plugin * kotlin-lombok-compiler-plugin * kotlin-noarg-compiler-plugin * kotlin-sam-with-receiver-compiler-plugin * kotlinx-serialization-compiler-plugin Every plugin has its -embeddable counterpart, for example, kotlin-allopen-compiler-plugin-embeddable is designed for working with the kotlin-compiler-embeddable artifact, the default option for scripting artifacts. Gradle adds these plugins as compiler arguments. You don't need to make any changes to your existing projects. Incremented minimum supported version Starting with Kotlin 1.9.0, the minimum supported Android Gradle plugin version is 4.2.2. See the Kotlin Gradle plugin's compatibility with available Gradle versions in our documentation. kapt doesn't cause eager task creation in Gradle Prior to 1.9.0, the kapt compiler plugin caused eager task creation by requesting the configured instance of the Kotlin compilation task. This behavior has been fixed in Kotlin 1.9.0. If you use the default configuration for your build.gradle.kts file then your setup is not affected by this change. If you use a custom configuration, your setup will be adversely affected. For example, if you have modified the KotlinJvmCompile task using Gradle's tasks API, you must similarly modify the KaptGenerateStubs task in your build script. For example, if your script has the following configuration for the KotlinJvmCompile task: tasks.named<KotlinJvmCompile>(\"compileKotlin\") { // Your custom configuration } In this case, you need to make sure that the same modification is included as part of the KaptGenerateStubs task: tasks.named<KaptGenerateStubs>(\"kaptGenerateStubs\") { // Your custom configuration } For more information, see our YouTrack ticket. Programmatic configuration of the JVM target validation mode Before Kotlin 1.9.0, there was only one way to adjust the detection of JVM target incompatibility between Kotlin and Java. You had to set kotlin.jvm.target.validation.mode=ERROR in your gradle.properties for the whole project. You can now also configure it on the task level in your build.gradle.kts file: tasks.named<org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile>(\"compileKotlin\") { jvmTargetValidationMode.set(org.jetbrains.kotlin.gradle.dsl.jvm.JvmTargetValidationMode.WARNING) } Standard library Kotlin 1.9.0 has some great improvements for the standard library: * The ..< operator and time API are Stable. * The Kotlin/Native standard library has been thoroughly reviewed and updated * The @Volatile annotation can be used on more platforms * There's a common function to get a regex capture group by name * The HexFormat class has been introduced to format and parse hexadecimals Stable ..< operator for open-ended ranges The new ..< operator for open-ended ranges that was introduced in Kotlin 1.7.20 and became Stable in 1.8.0. In 1.9.0, the standard library API for working with open-ended ranges is also Stable. Our research shows that the new ..< operator makes it easier to understand when an open-ended range is declared. If you use the until infix function, it's easy to make the mistake of assuming that the upper bound is included. Here is an example using the until function: fun main() { for (number in 2 until 10) { if (number % 2 == 0) { print(\"$number \") } } // 2 4 6 8 } And here is an example using the new ..< operator: fun main() { for (number in 2..<10) { if (number % 2 == 0) { print(\"$number \") } } // 2 4 6 8 } From IntelliJ IDEA version 2023.1.1, a new code inspection is available that highlights when you can use the ..< operator. For more information about what you can do with this operator, see What's new in Kotlin 1.7.20. Stable time API Since 1.3.50, we have previewed a new time measurement API. The duration part of the API became Stable in 1.6.0. In 1.9.0, the remaining time measurement API is Stable. The old time API provided the measureTimeMillis and measureNanoTime functions, which aren't intuitive to use. Although it is clear that they both measure time in different units, it isn't clear that measureTimeMillisuses a wall clock to measure time, whereas measureNanoTime uses a monotonic time source. The new time API resolves this and other issues to make the API more user friendly. With the new time API, you can easily: * Measure the time taken to execute some code using a monotonic time source with your desired time unit. * Mark a moment in time. * Compare and find the difference between two moments in time. * Check how much time has passed since a specific moment in time. * Check whether the current time has passed a specific moment in time. Measure code execution time To measure the time taken to execute a block of code, use the measureTime inline function. To measure the time taken to execute a block of code and return the result of the block of code, use the measureTimedValue inline function. By default, both functions use a monotonic time source. However, if you want to use an elapsed real-time source, you can. For example, on Android the default time source System.nanoTime() only counts time while the device is active. It loses track of time when the device enters deep sleep. To keep track of time while the device is in deep sleep, you can create a time source that uses SystemClock.elapsedRealtimeNanos() instead: object RealtimeMonotonicTimeSource : AbstractLongTimeSource(DurationUnit.NANOSECONDS) { override fun read(): Long = SystemClock.elapsedRealtimeNanos() } Mark and measure differences in time To mark a specific moment in time, use the TimeSource interface and the markNow() function to create a TimeMark. To measure differences between TimeMarks from the same time source, use the subtraction operator (-): import kotlin.time.* ​ fun main() { val timeSource = TimeSource.Monotonic val mark1 = timeSource.markNow() Thread.sleep(500) // Sleep 0.5 seconds. val mark2 = timeSource.markNow() ​ repeat(4) { n -> val mark3 = timeSource.markNow() val elapsed1 = mark3 - mark1 val elapsed2 = mark3 - mark2 ​ println(\"Measurement 1.${n + 1}: elapsed1=$elapsed1, elapsed2=$elapsed2, diff=${elapsed1 - elapsed2}\") } // It's also possible to compare time marks with each other. println(mark2 > mark1) // This is true, as mark2 was captured later than mark1. } Open in Playground → Target: JVM Running on v.2.3.0 To check if a deadline has passed or a timeout has been reached, use the hasPassedNow() and hasNotPassedNow() extension functions: import kotlin.time.* import kotlin.time.Duration.Companion.seconds ​ fun main() { val timeSource = TimeSource.Monotonic val mark1 = timeSource.markNow() val fiveSeconds: Duration = 5.seconds val mark2 = mark1 + fiveSeconds ​ // It hasn't been 5 seconds yet println(mark2.hasPassedNow()) // false ​ // Wait six seconds Thread.sleep(6000) println(mark2.hasPassedNow()) // true } Open in Playground → Target: JVM Running on v.2.3.0 The Kotlin/Native standard library's journey towards stabilization As our standard library for Kotlin/Native continues to grow, we decided that it was time for a complete review to ensure that it meets our high standards. As part of this, we carefully reviewed every existing public signature. For each signature, we considered whether it: * Has a unique purpose. * Is consistent with other Kotlin APIs. * Has similar behavior to its counterpart for the JVM. * Is future-proof. Based on these considerations, we made one of the following decisions: * Made it Stable. * Made it Experimental. * Marked it as private. * Modified its behavior. * Moved it to a different location. * Deprecated it. * Marked it as obsolete. If an existing signature has been: * Moved to another package, then the signature still exists in the original package but it's now deprecated with deprecation level: WARNING. IntelliJ IDEA will automatically suggest replacements upon code inspection. * Deprecated, then it's been deprecated with deprecation level: WARNING. * Marked as obsolete, then you can keep using it, but it will be replaced in future. We won't list all of the results of the review here, but here are some of the highlights: * We stabilized the Atomics API. * We made kotlinx.cinterop Experimental and now require different opt-ins for the package to be used. For more information, see Explicit C-interoperability stability guarantees. * We marked the Worker class and its related APIs as obsolete. * We marked the BitSet class as obsolete. * We marked all public APIs in the kotlin.native.internal package as private or moved them to other packages. Explicit C-interoperability stability guarantees To maintain the high quality of our API, we decided to make kotlinx.cinterop Experimental. Although kotlinx.cinterop has been thoroughly tried and tested, there is still room for improvement before we are satisfied enough to make it Stable. We recommend that you use this API for interoperability but that you try to confine its use to specific areas in your projects. This will make your migration easier once we begin evolving this API to make it Stable. If you want to use C-like foreign APIs such as pointers, you must opt in with @OptIn(ExperimentalForeignApi), otherwise your code won't compile. To use the remainder of kotlinx.cinterop, which covers Objective-C/Swift interoperability, you must opt in with @OptIn(BetaInteropApi). If you try to use this API without the opt-in, your code will compile but the compiler will raise warnings that provide a clear explanation of what behavior you can expect. For more information about these annotations, see our source code for Annotations.kt. For more information on all of the changes as part of this review, see our YouTrack ticket. We'd appreciate any feedback you might have! You can provide your feedback directly by commenting on the ticket. Stable @Volatile annotation If you annotate a var property with @Volatile, then the backing field is marked so that any reads or writes to this field are atomic, and writes are always made visible to other threads. Prior to 1.8.20, the kotlin.jvm.Volatile annotation was available in the common standard library. However, this annotation was only effective on the JVM. If you used it on other platforms, it was ignored, which led to errors. In 1.8.20, we introduced an experimental common annotation, kotlin.concurrent.Volatile, which you could preview in both the JVM and Kotlin/Native. In 1.9.0, kotlin.concurrent.Volatile is Stable. If you use kotlin.jvm.Volatile in your multiplatform projects, we recommend that you migrate to kotlin.concurrent.Volatile. New common function to get regex capture group by name Prior to 1.9.0, every platform had its own extension to get a regular expression capture group by its name from a regular expression match. However there was no common function. It wasn't possible to have a common function prior to Kotlin 1.8.0, because the standard library still supported JVM targets 1.6 and 1.7. As of Kotlin 1.8.0, the standard library is compiled with JVM target 1.8. So in 1.9.0, there is now a common groups function that you can use to retrieve a group's contents by its name for a regular expression match. This is useful when you want to access the results of regular expression matches belonging to a particular capture group. Here is an example with a regular expression containing three capture groups: city, state, and areaCode. You can use these group names to access the matched values: fun main() { val regex = \"\"\"\\b(?<city>[A-Za-z\\s]+),\\s(?<state>[A-Z]{2}):\\s(?<areaCode>[0-9]{3})\\b\"\"\".toRegex() val input = \"Coordinates: Austin, TX: 123\" val match = regex.find(input)!! println(match.groups[\"city\"]?.value) // Austin println(match.groups[\"state\"]?.value) // TX println(match.groups[\"areaCode\"]?.value) // 123 } New path utility to create parent directories In 1.9.0 there is a new createParentDirectories() extension function that you can use to create a new file with all the necessary parent directories. When you provide a file path to createParentDirectories() it checks whether the parent directories already exist. If they do, it does nothing. However, if they do not, it creates them for you. createParentDirectories() is particularly useful when you are copying files. For example, you can use it in combination with the copyToRecursively() function: sourcePath.copyToRecursively( destinationPath.createParentDirectories(), followLinks = false ) New HexFormat class to format and parse hexadecimals The new HexFormat class and its related extension functions are Experimental, and to use them, you can opt in with @OptIn(ExperimentalStdlibApi::class) or the compiler argument -opt-in=kotlin.ExperimentalStdlibApi. In 1.9.0, the HexFormat class and its related extension functions are provided as an Experimental feature that allows you to convert between numerical values and hexadecimal strings. Specifically, you can use the extension functions to convert between hexadecimal strings and ByteArrays or other numeric types (Int, Short, Long). For example: println(93.toHexString()) // \"0000005d\" The HexFormat class includes formatting options that you can configure with the HexFormat{} builder. If you are working with ByteArrays you have the following options, which are configurable by properties: Option Description upperCase Whether hexadecimal digits are upper or lower case. By default, lower case is assumed. upperCase = false. bytes.bytesPerLine The maximum number of bytes per line. bytes.bytesPerGroup The maximum number of bytes per group. bytes.bytesSeparator The separator between bytes. Nothing by default. bytes.bytesPrefix The string that immediately precedes a two-digit hexadecimal representation of each byte, nothing by default. bytes.bytesSuffix The string that immediately succeeds a two-digit hexadecimal representation of each byte, nothing by default. For example: val macAddress = \"001b638445e6\".hexToByteArray() // Use HexFormat{} builder to separate the hexadecimal string by colons println(macAddress.toHexString(HexFormat { bytes.byteSeparator = \":\" })) // \"00:1b:63:84:45:e6\" // Use HexFormat{} builder to: // * Make the hexadecimal string uppercase // * Group the bytes in pairs // * Separate by periods val threeGroupFormat = HexFormat { upperCase = true; bytes.bytesPerGroup = 2; bytes.groupSeparator = \".\" } println(macAddress.toHexString(threeGroupFormat)) // \"001B.6384.45E6\" If you are working with numeric types, you have the following options, which are configurable by properties: Option Description number.prefix The prefix of a hexadecimal string, nothing by default. number.suffix The suffix of a hexadecimal string, nothing by default. number.removeLeadingZeros Whether to remove leading zeros in a hexadecimal string. By default, no leading zeros are removed. number.removeLeadingZeros = false For example: // Use HexFormat{} builder to parse a hexadecimal that has prefix: \"0x\". println(\"0x3a\".hexToInt(HexFormat { number.prefix = \"0x\" })) // \"58\" Documentation updates The Kotlin documentation has received some notable changes: * The tour of Kotlin – Learn the fundamentals of the Kotlin programming language with chapters including both theory and practice. * Android source set layout – Learn about the new Android source set layout. * Compatibility guide for Kotlin Multiplatform – Learn about the incompatible changes you might encounter while developing projects with Kotlin Multiplatform. * Kotlin Wasm – Learn about Kotlin/Wasm and how you can use it in your Kotlin Multiplatform projects. Install Kotlin 1.9.0 Check the IDE version IntelliJ IDEA 2022.3.3 and 2023.1.1 automatically suggest updating the Kotlin plugin to version 1.9.0. IntelliJ IDEA 2023.2 will include the Kotlin 1.9.0 plugin. Android Studio Giraffe (223) and Hedgehog (231) will support Kotlin 1.9.0 in their upcoming releases. The new command-line compiler is available for download on the GitHub release page. Configure Gradle settings To download Kotlin artifacts and dependencies, update your settings.gradle(.kts) file to use the Maven Central repository: pluginManagement { repositories { mavenCentral() gradlePluginPortal() } } If the repository is not specified, Gradle uses the sunset JCenter repository, which could lead to issues with Kotlin artifacts. Compatibility guide for Kotlin 1.9.0 Kotlin 1.9.0 is a feature release and can, therefore, bring changes that are incompatible with your code written for earlier versions of the language. Find the detailed list of these changes in the Compatibility guide for Kotlin 1.9.0.",
        "crawl_status": "success"
      }
    ],
    "expected_years": [
      2024,
      2025,
      2023
    ],
    "actual_years": [],
    "years_extracted": [
      null,
      null,
      null
    ],
    "reason": "年份分布不符合要求（2023、2024、2025各一个）"
  },
  {
    "library": "Kotlinx-Datetime",
    "entries": [
      {
        "library_name": "Kotlinx-Datetime",
        "url": "https://github.com/Kotlin/kotlinx-datetime/releases/tag/v0.7.0",
        "version": "v0.7.0",
        "title": "Release v0.7.0 · Kotlin/kotlinx-datetime · GitHub",
        "release_date": "2025-06-24T14:52:21Z",
        "content": "Breaking changes:\nRemove\nkotlinx.datetime.Instant\nand\nkotlinx.datetime.Clock\nin favor of\nkotlin.time.Instant\n(\n#506\n). See\nhttps://github.com/Kotlin/kotlinx-datetime?tab=readme-ov-file#deprecation-of-instant\nfor a description of what to do if this causes problems.\nUnify the range of admissible\nLocalDate\nand\nLocalDateTime\nvalues on all platforms (\n#432\n).\nRename\ndayOfMonth\nto\nday\n,\nmonthNumber\nto\nmonth\n(\n#84\n).\nMake\nDayOfWeek\nand\nMonth\nno longer type aliases to\njava.time.DayOfWeek\nand\njava.time.Month\n(\n#96\n).\nMake\n\"UTC\"\nand not\n\"Z\"\nbe the timezone identifier for\nTimeZone.UTC\n(\n#474\n).\nAccept\n\"z\"\nin\nTimeZone.of\n, with the same meaning as\n\"Z\"\n(\n#529\n).\nAdd\nDateTimeFormat\n-based\nKSerializer\nimplementations for datetime entities, and change the default serializers to be based on\ntoString\n/\nparse\npairs (\n#415\n).\nAdditions:\nAdd\njava.io.Serializable\nimplementations for most of the entities in the library (\n#143\n). Thanks for spotting and fixing a potential vulnerability,\n@lukellmann\n!\nAdd\nLocalDateRange\n, a range of\nLocalDate\nvalues (\n#190\n). Thanks,\n@PeterAttardo\n!\nAdd\nYearMonth\nand\nYearMonthRange\n(\n#457\n).\nTweaks and fixes:\nSupport obtaining the system timezone on old Debian-based distributions (\n#430\n).\nFix not being able to parse some valid timezone identifiers using the\ntimeZoneId()\ndirective (\n#444\n).\nUse the grammar defined in RFC 9557 for parsing timezone identifiers in the\ntimeZoneId()\ndirective, allowing parsing values not present in the timezone database (\n#531\n).\nImproved error messages when formatting an invalid\nDateTimeComponents\nvalue (\n#471\n).\nSet the JPMS dependency on\nkotlinx.serialization.core\nto be optional (\n#496\n).",
        "crawl_status": "success"
      },
      {
        "library_name": "Kotlinx-Datetime",
        "url": "https://github.com/Kotlin/kotlinx-datetime/releases/tag/v0.4.0",
        "version": "v0.4.0",
        "title": "Release v0.4.0 · Kotlin/kotlinx-datetime · GitHub",
        "release_date": "2022-06-25T15:42:28Z",
        "content": "Add the\nLocalTime\nclass for representing time-of-day (\n#57\n). Thank you,\n@bishiboosh\n!\nProvide\nLocalTime#toSecondOfDay\n,\nLocalTime.fromSecondOfDay\n, and various other functions for compact representation of\nLocalTime\n(\n#204\n). Thank you,\n@vanniktech\n!\nProvide\nLocalDate#toEpochDays\n,\nLocalDate.fromEpochDays\nfor representing a\nLocalDate\nas a single number (\n#214\n).\nRename\nClock.todayAt\nto\nClock.todayIn\nfor naming consistency (\n#206\n).\nUpdate the Kotlin dependency to 1.7.0.",
        "crawl_status": "success"
      },
      {
        "library_name": "Kotlinx-Datetime",
        "url": "https://github.com/Kotlin/kotlinx-datetime/releases/tag/v0.6.0",
        "version": "v0.6.0",
        "title": "Release v0.6.0 · Kotlin/kotlinx-datetime · GitHub",
        "release_date": "2024-05-14T16:07:29Z",
        "content": "Introduce the widely requested API for locale-invariant parsing and formatting (\n#343\n)\nCompletely overhaul the KDoc-based documentation (\n#347\n)\nBreaking change: forbid parsing\nInstant\nvalues without the second-of-minute component on the JVM and JS, fixing inconsistency with Native (\n#369\n)\nBreaking change: use the fully qualified name of classes in the JSON serializers (\n#308\n)\nFix Proguard emitting warning about missing\nkotlinx-serialization\nclasses when serialization is not used (\n#336\n)\nReimplement the timezone database handling for Native targets from scratch (\n#286\n,\n#327\n)\nSupport Android NDK targets (\n#344\n)\nSmall tweaks and fixes.\nChangelog relative to version 0.6.0-RC.2\nCompletely overhaul the KDoc-based documentation (\n#347\n)\nBreaking change: forbid parsing\nInstant\nvalues without the second-of-minute component on the JVM and JS, fixing inconsistency with Native (\n#369\n)\nImprove error descriptiveness in some cases (\n#360\n,\n#371\n)\nRemove\nstat\nusages to comply with Apple's new publishing requirements (\n#385\n)\nFix parsing of formats where\noptional\nis directly between numbers (\n#362\n)\nForbid empty and duplicate month, day-of-week, and AM/PM marker names in datetime formats (\n#362\n)\nNew Contributors\n@whyoleg\nmade their first contribution in\n#323\n@qwwdfsad\nmade their first contribution in\n#308\n@shanshin\nmade their first contribution in\n#380\nFull Changelog\n:\nv0.5.0...v0.6.0",
        "crawl_status": "success"
      }
    ],
    "expected_years": [
      2024,
      2025,
      2023
    ],
    "actual_years": [
      2024,
      2025
    ],
    "years_extracted": [
      2025,
      null,
      2024
    ],
    "reason": "年份分布不符合要求（2023、2024、2025各一个）"
  },
  {
    "library": "Multiplatform-Settings",
    "entries": [
      {
        "library_name": "Multiplatform-Settings",
        "url": "https://github.com/russhwolf/multiplatform-settings/releases/tag/v1.2.0",
        "version": "v1.2.0",
        "title": "Release v1.2.0 · russhwolf/multiplatform-settings · GitHub",
        "release_date": "2024-09-02T02:42:52Z",
        "content": "Update to Kotlin 2.0.0, Gradle 8.7, and Android Gradle Plugin 8.3.2\nAdd alternative APIs to\nmultiplatform-settings-serialization\nthat don't require manually passing a serializer (\n#172\n). Thanks for contributions by\n@findusl\nNew experimental module\nmultiplatform-settings-make-observable\nto convert non-observable settings to observable by\nwiring in callbacks when platform observability APIs don't exist (\n#155\n,\n#184\n). Thanks for contributions by\n@psuzn\n.\nAdd all supported targets to\nmultiplatform-settings-coroutines\nand\nmultiplatform-settings-serialization\n, including\nwasmJs\n.\nAdd additional targets to\nmultiplatform-settings-datastore\nbased on multiplatform Datastore version 1.1.0\nAdd\nwasmWasi\nsupport to\nmultiplatform-settings\n,\nmultiplatform-settings-test\n, and\nmultiplatform-settings-make-observable\n.\nAdd\nStateflow\nanalogs to existing\nFlow\nextensions in\nmultiplatform-settings-coroutines\n. (\n#156\n)\nMake\nSettingsInitializer\npublic so it's easier to configure custom android.startup initialization or write tests\nwhen using\nmultiplatform-settings-no-arg\nAdjust\nKeychainSettings\nto avoid duplicated authentication requests (\n#193\n). Thanks for contributions by\n@crysxd\nModernize gradle and publication config. This shouldn't impact consumers, but please file an issue if you notice\nanything missing.",
        "crawl_status": "success"
      },
      {
        "library_name": "Multiplatform-Settings",
        "url": "https://github.com/russhwolf/multiplatform-settings/releases/tag/v1.1.0",
        "version": "v1.1.0",
        "title": "Release v1.1.0 · russhwolf/multiplatform-settings · GitHub",
        "release_date": "2023-10-09T12:41:40Z",
        "content": "Update to Kotlin 1.9.10, Gradle 8.3, and Android Gradle Plugin 8.1.2\nRemove deprecated Kotlin/Native targets\nAdd wasm browser target to\nmultiplatform-settings\n,\nmultiplatform-settings-test\n, and\nmultiplatform-settings-no-arg\n(issue\n#142\n). This uses the same\nStorageSettings\nimplementation as in the current js target.\nUse Dispatchers.IO rather than Dispatchers.Default in\nmultiplatform-settings-coroutines\non platforms where it is available (issue\n#157\n)\nAdd serialization-aware\nremoveValue()\nand\ncontainsValue()\nfunctions to\nmultiplatform-settings-serialization\n(issue\n#81\n)\nFix issue with serialization delegates incorrectly falling back to default values (issues\n#160\nand\n#162\n)",
        "crawl_status": "success"
      },
      {
        "library_name": "Multiplatform-Settings",
        "url": "https://github.com/russhwolf/multiplatform-settings/releases/tag/v0.9",
        "version": "v0.9",
        "title": "Release v0.9 · russhwolf/multiplatform-settings · GitHub",
        "release_date": "2022-05-02T02:40:22Z",
        "content": "Update to Kotlin 1.6.21 and Gradle 7.3.2\nUpdate\nmultiplatform-settings-coroutines\nto use coroutines version 1.6.1\nUpdate\nmultiplatform-settings-serialization\nto use serialization version 1.3.2\nAdd Windows support to\nmultiplatform-settings-no-arg\nAdd JVM support to\nmultiplatform-settings-datastore\nRefactor some internals to take advantage of better HMPP support in Kotlin 1.6+\nFix a crash that could occur on Android 11 and above when clearing data from SharedPreferences while listeners were set by AndroidSettings",
        "crawl_status": "success"
      }
    ],
    "expected_years": [
      2024,
      2025,
      2023
    ],
    "actual_years": [
      2024,
      2023
    ],
    "years_extracted": [
      2024,
      2023,
      null
    ],
    "reason": "年份分布不符合要求（2023、2024、2025各一个）"
  }
]